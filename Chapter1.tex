%------------------------------------------------------------------------------

\chapter{Εισαγωγή}
\label{chapter1} % \ref{}

\section{Γενικά}

Σε αυτό το κεφάλαιο αποσκοπούμε να ενημερώσουμε τον αναγνώστη γενικά περί
δυναμικών γλωσσών προγραμματισμού και πιο συγκεκριμένα για την διαδικασία
μεταγλώττισης τέτοιων γλωσσών και τα προβλήματα που αντιμετωπίζει κανείς.
Θεωρούμε ότι ο αναγνώστης ήδη κατέχει μια σχετικά καλή ιδέα για προγραμματισμό
για τις κάποιες από τις λεπτομέρειες που διέπουν τους μεταφραστές τους.

%------------------------------------------------------------------------------

\section{Δυναμικές Γλώσσες}

Ο όρος είναι λίγο ασαφής αλλά γενικά ως δυναμική γλώσσα εννοούμε μια γλώσσα
προγραμματισμού πολύ υψηλού επιπέδου, που παρουσιάζει συμπεριφορές υψηλής
αφαιρετικότητας κατά της εκτέλεση του προγράμματος, σε αντίθεση με άλλες γλώσσες
στις οποίες αυτό λαμβάνει χώρα κατά την μετάφραση του κώδικα σε κώδικα μηχανής.
Συνήθως τα προγράμματα αυτών των γλωσσών δεν μεταφράζονται απευθείας, αλλά ένα
ειδικό πρόγραμμα – το οποίο καλείται μεταγλωττιστής (interpreter) αναλαμβάνει να
τα "τρέξει", με την όλη διαδικασία της μετατροπής (του υψηλού επιπέδου κώδικα σε
κώδικα μηχανής) να λαμβάνει χώρα κατά το runtime· δηλαδή κατά την διάρκεια που ο
χρήστης τρέχει το πρόγραμμα και όχι κατά την μεταγλώττιση όπως συμβαίνει με
άλλες γλώσσες εξίσου υψηλού επιπέδου (βλ. Rust).

Τα χαρακτηριστικά και οι υποκατηγορίες των δυναμικών γλωσσών βρίθουν και η
ολοκληρωμένη λεπτομερής απαρίθμησή τους είναι εκτός των σκοπών αυτής της
εργασίας. Το σημαντικότερο κοινό χαρακτηριστικό είναι η χρήση του μεταγλωττιστή
και το "τρέξιμο" του προγράμματος στο περιβάλλον που δημιουργεί αυτό. Η
λειτουργία δηλαδή αυτή είναι σαν μια εικονική μηχανή και αυτό μας δίνει
απευθείας την δυνατότητα για ένα ακόμα επίπεδο αφαιρετικότητας στα design
patterns του προγραμματισμού μας. Έτσι έχουμε πράγματα όπως metaprogramming και
φυσικά δυναμικούς τύπους.

Οι δυναμικοί τύποι είναι το σημαντικότερο χαρακτηριστικό από την μεριά του
χρήστη, φυσικά για την ευκολία που δίνει σε αυτόν η εκάστοτε γλώσσα. Ο χρήστης
δεν χρειάζεται να δηλώσει ρητά τον τύπο μιας μεταβλητής. Αυτος συμπεραίνεται από
την αρχικοποίηση ή τα "συμφραζόμενα" της μεταβλητής μέσα στο πρόγραμμα. Επίσης
σημαντικό είναι ότι σε μερικές από αυτές τις γλώσσες μπορεί να αλλάξει κατά την
διάρκεια της εκτέλεσης.

Άλλο ένα τέτοιο σύγχρονο χαρακτηριστικό υψηλού επιπέδου είναι το just-in-time
compilation αλλά δεν θα ασχοληθούμε καθόλου με αυτό.

Οι δυναμικές γλώσσες ήταν πάντα δημοφιλείς, αλλά στις μέρες μας οι καινούργιες
συνθήκες, η ολοένα αυξημένη υπολογιστική ισχύ, και οι μεγάλες ομάδες (με πληθώρα
αναγκών) πίσω από τον σχεδιασμό των γλωσσών, έχουν οδηγήσει σε νέες  πτυχές στον
κόσμο των γλωσσών και του προγραμματισμού. Πολύ συχνά "αναδύονται" καινούργια
χαρακτηριστικά για συγκεκριμένες ανάγκες ή κάποιο είδος  αφαίρετικότητας τα
καταστεί πιο εύκολα. Η ώθηση αυτή, που διέπει αυτά τα  communities των δυναμικών
γλωσσών, είναι μια ισορροπία μεταξύ πρακτικότητας και κομψότητας. Τα
χαρακτηριστικά των γλωσσών αυτών τείνουν να μεγαλώνουν (με  εξαίρεση την
Python), στην οποία ακόμα διατηρείται ένα μινιμαλιστικό mindset. Σχεδόν σε όλες,
αντί για κάποιο καινούργιο abstraction (το οποίο θα προερχόταν  ή θα οδηγούσε σε
κάποια καινοτομία), προτιμάται ένα μεγάλο πλήθος μικρών μικρών  βελτιωτικών
χαρακτηριστικών, καθώς στοχεύουν να είναι εύκολες στην καθημερινή  χρήση και από
τον πιο ανειδίκευτο προγραμματιστή. Θα μπορούσε κανείς να πει,  ότι αυτές οι
γλώσσες είναι περισσότερο βιβλιοθήκες (libraries) πάνω σε μια απλή  γλώσσα (core
language). Τέλος, είναι προφανές, ότι το λιγότερο σημαντικό  χαρακτηριστικό για
αυτές τις γλώσσες είναι οι επιδόσεις. Πολλές φορές γίνονται  επιλογές (κατά τον
σχεδιασμό τους) υπέρ της ευκολίας χρήσης αντί των επιδόσεων. Όμως ακόμα και σε
άλλη περίπτωση, λόγω του μεγάλου αριθμού constructions στις  γλώσσες, η στατική
ανάλυση, το inference και η βελτιστοποίηση έχουν καταστεί  εξαιρετικά δύσκολες.


\subsection{Python}

\subsubsection{Γενικά - Ιστορία}

Συγκεκριμένα η γλώσσα, με την οποία θα ασχοληθούμε και στην οποία θα
υλοποιήσουμε το module, είναι η \textit{Python}\cite{python}. Η Python είναι μια
γενικού σκοπού δυναμική, "πολύ-παραδειγματική", υψηλού επιπέδου γλώσσα η οποία
είναι εξαιρετικά δημοφιλής εδώ και πολλά χρόνια. Η φιλοσοφία της δίνει βάση στην
καλή αναγνωσιμότητα του κώδικάς της και στην ευκολία της χρήσης. Υπάρχουν
υλοποιήσεις σχεδόν σε όλες τις  πλατφόρμες\footnote{π.χ. σε C, C\#, Java κλπ, με
την πιο δημοφιλής (και το reference για τις άλλες) να είναι η λεγόμενη CPython
σε C} και πολλές διαφορετικές εκδόσεις\footnote{βλ. Stackless Python} της και
πειράματα\footnote{βλ. pypy}. Επιπλέον λόγω της δημοτικότητάς της έχει επηρεάσει
πολλές άλλες γλώσσες όλων των ειδών και έχει ουσιαστικά συμβάλει στην σημερινή
εικόνα του κόσμου των υπολογιστών.

Βασίζεται στην φιλοσοφία των πρωταρχικών ώριμων γλωσσών (όπως C, Java), δηλαδή
το κυρίως \textit{προγραμματιστικό παράδειγμά} της είναι ο "
Προστακτικός-Διαδικαστικός Προγραμματισμός" (imperative/declarative
programming) με πολλά στοιχεία – και ένα καλό σύστημα αντικειμένων
(object-oriented programming). Επίσης λέμε ότι "ξεχωρίζει" τις έννοιες
δεδομένων και κώδικα – δηλαδή ακολουθεί το παράδειγμα της C και όχι της lisp.
Έχει παρόλα αυτά και πολλές επιρροές και χαρακτηριστικά από συναρτησιακό
προγραμματισμό (functional programming).

Σε αντίθεση με άλλες παρόμοιες γλώσσες, η Python προτιμά τον μινιμαλισμό. Οι
τελικές – σχετικά αυστηρές – αποφάσεις στον σχεδιασμό της λαμβάνονται από τον
Guido van Rossum, ο οποίος έχει περιπαικτικά τον τίτλο του "Benevolent Dictator
For Life".\cite{guido}

\subsubsection{Χαρακτηριστικά - Ιδιαιτερότητες}

Από την άλλη, όπως οι περισσότερες γλώσσες, βασικό χαρακτηριστικό που τις διέπει
είναι η παντελής έλλειψη δηλώσεων (\textit{no declaration notion}). Κάθε
πρόγραμμα χτίζεται με εντολές. Υπάρχουν κάποιες εκφράσεις που μπορεί να μοιάζουν
με δηλώσεις, όπως οι "δήλωση" συνάρτησης. Στην πραγματικότητα δεν είναι, και
απλώς δημιουργείται ένα αντικείμενο (runtime object) που δρα ως συνάρτηση.
Όμοιως και στην περίπτωση των κλάσεων, και των module\footnote{βλ.
\texttt{import} statement}, τα οποία αποτελούν βασικό κομμάτι του οικοσυστήματος
της γλώσσας. Πράγματι, \textit{τα πάντα} είναι ένα runtime αντικείμενο για την
Python. Άπαξ και δημιουργηθεί ένα αντικείμενο, μια αναφορά (reference) σε αυτό,
θα αποθηκευτεί στην τοπική λίστα ονομάτων (\textit{namespace}), η οποία στην
Python λέγεται \textit{module}. Αυτή είναι και η "μονάδα" του προγράμματος στην
Python. Το κατώτερο module στην ιεραρχία λέγεται φυσικά main module και είναι η
αντίστοιχη main συνάρτηση του κάθε προγράμματος.

Άλλα χαρακτηριστικά της γλώσσας περιλαμβάνουν εξαιρετικά καλό σύστημα γεννητόρων
(\textit{generators}) και επαναληπτών (\textit{iterators}) που διευκολύνουν σε
μεγάλο βαθμό κάποιες συγκεκριμένες περιπτώσεις, σύστημα metaprogramming
βασισμένο σε μετακλάσεις, σύστημα σχολίων χτισμένο μέσα στη γλώσσα (docstrings),
κ.α.

Ακολουθεί ένα μικρό παράδειγμα για μια πρώτη γεύση με την γλώσσα. Είναι κομμάτι
της build-in βιβλιοθήκης και υλοποιεί έναν μετρητή με την μορφή iterator.
Σημαντική είναι η χρήση whitespace για το identation. Αυτό οδηγεί σε κώδικα με
ακόμα μεγαλύτερη αναγνωσιμότητα.
\lstinputlisting[language=Python]{example.py}

%------------------------------------------------------------------------------

\section{Μεταγλώττιση Δυναμικών Γλωσσών}

Ο λεγόμενος μεταγλωττιστής (interpreter) είναι ο αντίστοιχος του μεταφραστής
(compiler) στις "στατικές" γλώσσες. Αντί να μεταφράζει εξ ολοκλήρου το
πρόγραμμα σε κώδικα μηχανής (και να εκτελεί όλες τις διαδικασίες για τις οποίες
είναι προγραμματισμένος) κατά την διάρκεια του compile-time (την ώρα που τρέχει
ο compiler για να "παράγει" το πρόγραμμα), το κάνει όταν αυτό χρειαστεί - και
αν χρειαστεί - κατά την διάρκεια του runtime. Όπως είδαμε στην προηγούμενη
ενότητα, δεν υπάρχει μια σταθερή δομή δηλώσεων (η οποία να μπορεί να αναλυθεί),
οπότε η μεταγλώττιση και ειδικά η βελτιστοποίηση είναι πολύ δύσκολες. Θεωρητικά
η γλώσσα θα μπορούσε να δημιουργήσει μια κλάση με εκατοντάδες τελείως
διαφορετικούς τρόπους βάσει αποτελεσμάτων από NP-complete υπολογισμούς και
εξωτερικούς παράγοντες.\cite{rigo2005}

\subsection{pypy}

\subsubsection{Τι είναι το pypy}

Το framework που θα χρησιμοποιήσουμε λέγεται pypy\cite{pypy}. Το pypy ξεκίνησε
το 2007 ως μια απόπειρα για έναν interpreter της Python γραμμένο στην ίδια την
γλώσσα\footnote{βλ. bootstrapping}. Από τότε έχει εξελιχθεί σε ένα ολοκληρωμένο
\textit{framework} με πολλές μοντέρνες δυνατότητες όπως \textit{JIT
compilation}. Αποτελείται από 2 μεγάλα subprojects:

\begin{itemize}

\item \textbf{RPython framework}

Το πρώτο είναι ένα compiler framework. Είναι γραμμένο σε κανονική Python, και
ουσιαστικά είναι μια βάση – ένα πρόγραμμα το οποίο μπορεί να παράγει compilers.
Μπορεί να "διαβάσει" μια ειδική περιορισμένη έκδοση της Python (που λέγεται
RPython). Οι διαφορές που έχει είναι ότι στερείται κάποιων κατασκευών υψηλής
αφαιρετικότητας. Έχει παρόλα αυτά πολλά από τα γνωστά χαρακτηριστικά της Python.

Σε αυτό το framework έχουν γραφτεί πλέον μεταφραστές και σε άλλες γλώσσες πέραν
μόνο της αρχικής Python, που "περιλαμβάνεται" στο project. Το πιο γνωστό
παράδειγμα είναι το Topaz\cite{topaz}.


\item \textbf{pypy}

Το δεύτερο πρότζεκτ είναι το pypy. Ένας compiler της Python γραμμένος βάσει του
προηγούμενου framework, σε RPython. Έχει πλέον ξεπεράσει σε ταχύτητα και
αποδοτικότητα τον CPython, τον reference compiler της γλώσσας. Οι λόγοι που δεν
ανακηρύσσεται αυτός reference compiler είναι "διοικητικοί"\footnote{βλ. Guido
van Rossum}. Βέβαια υπάρχουν και μερικά προβλήματα με παλιό κώδικα (legacy code)
και library support. Οι λόγοι μάλλον που ο compiler δεν είναι drop-in
replacement βέβαια, είναι λόγοι εμπιστοσύνης.

\end{itemize}

Φυσικά όπως όλα τα μεγάλα project έχει modular δομή κώδικα για πιο εύκολη
διαχείριση του τεράστιου πλέον όγκου του. Εμείς θα υλοποιήσουμε ένα τέτοιο
module στο υποσύστημα του backend optimization.

\subsubsection{Ανάλυση προγραμμάτων}

Το pypy, όπως και όλοι οι μεταγλωττιστές δυναμικών γλωσσών, αναλύει το κάθε
πρόγραμμα "ζωντανά" (live program analysis), δηλαδή στην μνήμη και όχι ως
"νεκρά"\footnote{στατικά} αρχεία. Αυτό σημαίνει ότι το πρόγραμμα φορτώνεται
(ίσως και ολόκληρο) αρχικά στην μνήμη και προχωρά η διαδικασία της
μεταγλώττισης. Όταν φτάσει σε ένα αρκετά καλό σημείο, θα μειωθεί η
"δυναμικότητά" του και θα αναλυθούν τα αντικείμενα που έχουν προκύψει στην
μνήμη. Ουστιαστικά η RPython είναι το υποσύνολο της Python που περιλαμβάνει μόνο
όσα χαρακτηριστικά υποστηρίζονται από αυτό το σύστημα ανάλυσης.

Στην περίπτωση που η ανάλυση γινόταν βάσει των στατικών αρχείων, τότε ουσιαστικά
θα ήταν σαν να "ακυρώναμε" την έννοια της δυναμικότητας της γλώσσας. Από την
άλλη, και η ανάλυση μιας \textit{σταθερής} εικόνας του προγράμματος στην μνήμη,
θα ήταν το ίδιο. Για αυτό και το σύστημα του pypy είναι εξαιρετικά δυναμικό.
Μπορεί να χειριστεί ακόμα και τελείως δυναμικά κομμάτια κώδικα εφόσον η είσοδος
της ροής σε αυτά είναι οριοθετημένη (bounded)\cite{rigo2005}. Είναι σημαντικό να
ξανά-αναφέρουμε ότι και το ίδιο το pypy είναι γραμμένο σε RPython, και αυτό
σημαίνει ότι και το ίδιο υφίσταται την ίδια δυναμική ανάλυση και απολαμβάνει τα
ίδια πλεονεκτήματα αυτής.

%------------------------------------------------------------------------------
