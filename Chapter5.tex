%------------------------------------------------------------------------------

\chapter{Αποτελέσματα – Συμπεράσματα}
\label{chapter5}

\section{Γενικά}

Σε αυτό το τελευταίο κεφάλαιο θα δώσουμε τα τελικό αποτελέσματα του εγχειρήματος
και μερικές παρατηρήσεις για τον κώδικα αυτόν. Θα προσπαθήσουμε να δώσουμε στον
αναγνώστη το μέγεθος της βελτίωσης που καταφέραμε να πετύχουμε με αυτόν τον
βελτιστοποιητή. Αξίζει να επαναλάβουμε εδώ ότι ο βελτιστοποιητής μας τρέχει κατά
το compile time του μεταγλωττιστή pypy και εφαρμόζεται πάνω στον κώδικά του ανά
συνάρτηση. Στοχεύουμε φυσικά στο να βελτιώσουμε τον χρόνο (και γενικότερα το
``κόστος") των συναρτήσεων αυτών. Στις μετρήσεις που ακολουθούν επικεντρωνόμαστε
στο χρονικό κόστος.

Να υπογραμμίσουμε εδώ ότι οι μετρήσεις έγιναν μόνο σε ένα machine (με Mac OS X
10.11.4 σε επεξεργαστή 2.3GHz Intel Core i5, 16GB 1333MHz RAM και SSD δίσκο) και
δεν προσπαθήσαμε να βρούμε κάποιο πιθανοτικό μοντέλο ή κατανομή, στην οποία θα
μπορούσαμε να εντάξουμε το data set των συναρτήσεών μας. Τα περισσότερα νούμερα
που παραθέτουμε, όπως θα δούμε, είναι μέσοι όροι, και πολλές φορές μέσοι όροι
από μέσους όρους για λόγους που θα δούμε παρακάτω. Πειραματιστήκαμε με πολλούς
μεθόδους για το πως θα μετρήσουμε την βελτιστοποίηση. Η αρχική σκέψη ήταν η απλή
σύγκριση τιμών χρόνου αλλά οι συναρτήσεις στις οποίες εφαρμόζεται η
βελτιστοποίηση μας είναι περισσότερες από 100000.

\section{Μετρήσεις}

\subsection{Getfield Removal}

Η πρώτη μετρική είναι μια απλή καταμέτρηση των εμφανίσεων της πιο συχνής και
ακριβής εντολής\footnote{Η εντολή \texttt{getfield} δεν είναι στην
πραγματικότητα η πιο ακριβή ως μονάδα, αλλά σίγουρα η πιο συχνή οπότε η πιο
ακριβή ως σύνολο.}, της \texttt{getfield}, που απλά στοχεύουμε να μειώσουμε.
Στην έκδοση του κώδικά μας που παραθέτουμε στο παράρτημα, η καταμέτρηση αυτή
γίνεται σε κάθε iteration μέσα στην κεντρική συνάρτηση και ο αριθμός
επιστρέφεται για ευκολότερη χρήση, και γρήγορα νούμερα. Φυσικά, κατά την
διαδικασία μέτρησης, γράψαμε διάφορα scripts για καλύτερα νούμερα. Αυτά τα
κομμάτια κώδικα θα αφαιρεθούν στην τελική έκδοση.

Η βελτιστοποίησή μας τρέχει πολλές φορές – αν και πάντα τελευταία όπως είπαμε –
κατά το στάδιο των βελτιστοποιήσεων αλλά τα δύο πρώτα runs είναι τα πιο
σημαντικά. Σε αυτά σκανάρονται οι πιο σημαντικές και βασικές συναρτήσεις του
framework. Παρακάτω στον πίνακα \ref{table-getfield} φαίνεται τα μέσα ποσοστά
των αριθμών των \texttt{getfield} εντολών που καταφέραμε να αφαιρέσουμε και ο
αριθμός όσων γραφημάτων αλλάξαμε. Τα ποσοστά δηλαδή περιλαμβάνουν μόνο τα
γραφήματα που άλλαξαν. Όπως μπορούμε να δούμε ένα περίπου 90\% των γραφημάτων
δεν άλλαξαν καθόλου. Αυτό μπορεί να οφείλεται σε πολλούς λόγους, είτε απλότητας
των γραφημάτων (οπότε και η βελτιστοποίηση γίνεται σε προηγούμενα στάδια) είτε
ανικανότητα της μεθόδου μας να ``πιάσουμε" τις πιθανές προς αφαίρεση μεταβλητές
λόγω μεγάλης πολυπλοκότητας του γραφήματος.

\begin{table}[]
\centering
\caption{General median percentage of getfield removal after partial escape application}
\label{table-getfield}
\begin{tabular}{lllll}
–– & \cellcolor[HTML]{C0C0C0}Total graphs/functions &
\cellcolor[HTML]{C0C0C0}Graphs that changed & \cellcolor[HTML]{C0C0C0}Getfield removal &  \\
\cellcolor[HTML]{C0C0C0}1o run & \multicolumn{1}{c}{21320} & \multicolumn{1}{c}{2154} & \multicolumn{1}{c}{18\%} &  \\
\cellcolor[HTML]{C0C0C0}2o run & \multicolumn{1}{c}{59433} & \multicolumn{1}{c}{3281} & \multicolumn{1}{c}{7\%} &  \\
 &  &  &  & 
\end{tabular}
\end{table}

Μπορούμε να βγάλουμε ένα γενικό συμπέρασμα ότι αφαιρούμε περίπου το 5\% των
εντολών από όλο το codebase του PyPy – είτε οποιουδήποτε Python codebase δοθεί.

\subsection{Malloc Removal}

Στη συνέχεια αποφασίσαμε να συλλέξουμε μετρήσεις για την ``ισχυρή" και ``ακριβή"
\texttt{malloc}. Εδώ η διαδικασία μετρήσεων είναι πιο πολύπλοκη καθώς η
βελτιστοποίηση αυτή τείνει να μην αφαιρεί τις εντολές αυτές με την ``συμβατική"
έννοια (δηλαδή να μειώνει τα \textit{counts} στον κώδικα) αλλά να μειώνει την
χρήση τους και πιο συγκεκριμένα την χρήση μνήμης εξωτερικής του \textit{stack}.

Επιπλέον υπάρχει ακόμα και η περίπτωση αύξησης του αριθμού των \texttt{malloc}
καθώς πολλές φορές έχουμε το εξής φαινόμενο: Αρχικά το αντικείμενο κρίνεται μη
απαραίτητο σε αυτό το σημείο του scan και αφαιρείται. Έπειτα, σε μερικά branches
της ροής εκτέλεσης μπορεί να κριθεί ότι απαιτείται και να επανατοποθετηθεί. Αυτό
μπορεί να γίνει σε μερικά branches λόγω του partiality της μεθόδου. Αφού τα
γραφήματα περνούν ήδη πιο πριν από συμβατικό escape analysis, αυτό το use case
θα είναι το πιο συχνό στο οποίο η δικιά μας βελτιστοποίηση θα δουλέψει. Για αυτό
το λόγω απλά θα μετρήσουμε εδώ τα γραφήματα, τα οποία επηρεάστηκαν (βλ. \ref
{table-malloc}).

\begin{table}[h]
\centering
\caption{Malloc changes}
\label{table-malloc}
\begin{tabular}{lllll}
–– & \cellcolor[HTML]{C0C0C0}Total graphs & \cellcolor[HTML]{C0C0C0}Mallocs got removed in... & \cellcolor[HTML]{C0C0C0} Mallocs got moved in... &  \\
\cellcolor[HTML]{C0C0C0}1o run & \multicolumn{1}{c}{21243} & \multicolumn{1}{c}{8} & \multicolumn{1}{c}{231} &  \\
\cellcolor[HTML]{C0C0C0}2o run & \multicolumn{1}{c}{59066} & \multicolumn{1}{c}{22} & \multicolumn{1}{c}{366} &  \\
 &  &  &  & 
\end{tabular}
\end{table}


Για να δείξουμε ότι παρόλα αυτά ο χρόνος φυσικά μειώνεται έχουμε την επόμενη
μετρική, η οποία Θα μετρήσει το μέσο κόστος της κάθε συνάρτησης.

\subsection{Time Cost}

Τέλος, θα δώσουμε μέσα κόστη εκτέλεσης. Καταλήξαμε στους μέσους όρους κόστους
εκτέλεσης (\textit{median executin cost}) καθώς φυσικά μιλάμε για υπολογιστικά
συστήματα οπότε το ένα run από το άλλο, ακόμα και της ίδιας συνάρτησης, μπορεί
να διαφέρει εκπληκτικά χρονικά. Χρησιμοποιούμε την συνάρτηση \\
\texttt{measure\_median\_execution\_cost()} του module \texttt{inline} στο PyPy
η οποία είναι εξαιρετικά βοηθητική και αποτέλεσε βασικό κομμάτι των μετρήσεών
μας. Η συνάρτηση αυτή, δοθείσας μιας συνάρτησης, επιστρέφει πάντα το ίδιο
νούμερο· το μέσο κόστος εκτέλεσης, οπότε ξέρουμε ότι είναι μια καλή μετρική.
Παρακάτω, στον πίνακα \ref{table-time} παραθέτουμε τα χρονικά κέρδη που είχαμε
σε ποσοστά. Τα ποσοστά βγήκαν φυσικά μεταξύ δύο runs της παραπάνω συνάρτησης
μέτρησης. Τρέχουμε πρώτα το αρχικό γράφημα που παίρνουμε από τον μεταγλωττιστή,
και αφού πάρουμε ένα μέσο κόστος για αυτό, περνάμε το γράφημα από τον
βελτιστοποιητή μας. Τέλος παίρνουμε άλλο ένα μέσο κόστος και βγάζουμε το
ποσοστό. Από όλα αυτά τα ποσοστά – για τα γραφήματα που επηρεάστηκαν – βγάζουμε
ένα γενικό ποσοστό. Αυτά δίνονται παρακάτω.

\begin{table}[h]
\centering
\caption{Time gains throughout all graphs}
\label{table-time}
\begin{tabular}{lllll}
–– & \cellcolor[HTML]{C0C0C0}Total graphs/functions & \cellcolor[HTML]{C0C0C0}Graphs that changed & \cellcolor[HTML]{C0C0C0}Time gain &  \\
\cellcolor[HTML]{C0C0C0}1o run & \multicolumn{1}{c}{21320} & \multicolumn{1}{c}{2230} & \multicolumn{1}{c}{4.5\%} &  \\
\cellcolor[HTML]{C0C0C0}2o run & \multicolumn{1}{c}{59433} & \multicolumn{1}{c}{4157} & \multicolumn{1}{c}{5.2\%} &  \\
 &  &  &  & 
\end{tabular}
\end{table}
Μπορούμε να βγάλουμε ένα γενικό συμπέρασμα ότι βελτιώνουμε περίπου κατά 1\% την
ταχύτητα του PyPy!

Όπως βλέπουμε και εδώ, δεν αλλάζουν όλα τα γραφήματα, αλλά σιγουρευτήκαμε, κατά
το tesing phase με πολλούς τρόπους, ότι ο χρόνος δεν αυξάνεται
(\textit{overhead}) σε απολύτως κανένα γράφημα. Βλέπουμε επίσης ότι οι αριθμοί
των γραφημάτων που άλλαξαν είναι περίπου ίδιοι και αυτό είναι λογικό αφού στα
γραφήματα που μπορέσαμε και αφαιρέσαμε εντολές, ο χρόνος αναμένουμε να είναι
σαφώς γρηγορότερος, όπως και είναι.


Να τονίσουμε εδώ ξανά ότι η βελτιστοποίηση αυτή τρέχει τελευταία· μετά από όλες
τις υπόλοιπες που υπάρχουν μέσα στο ώριμο PyPy project και μετά και από το
normal partial escape analysis που υπάρχει. Σε αντίθετη περίπτωση είμαστε
σίγουροι ότι ο βελτιστοποιητής θα ήταν πολύ πιο παραγωγικός.

Σημείωση: Τα πλήρη logs των μετρήσεων βρίσκονται εδώ:
\href{}{github.com/papanikge/thesis}

%------------------------------------------------------------------------------

\section{Μελλοντική εργασία}

Το παρόν εγχείρημα προέκυψε παραγωγικό και σύμφωνα με τα νούμερα που παραγάγαμε
πολύ αποτελεσματικό! Πραγματοποιήσαμε και προσφέραμε στο ευρύ κοινό μια
υλοποίηση της μεθόδου ανάλυσης μερικής διαφυγής και βελτιστοποίησης μέσω
αντικατάστασης βαθμωτών και συμβάλαμε φυσικά με τον δική μας μικρή βοήθεια στην
βελτίωση της ταχύτητας του μεταγλωττιστή του PyPy.

Ο μεγάλος όγκος των \texttt{malloc}s αφαιρούνται κατά την πρώτη \textit{build-
in} βελτιστοποίηση του PyPy (\textit{non-partial escape
analysis}\footnote{escape.py}). Η δικιά μας μέθοδος πυροδοτείται αργότερα και
παρόλα αυτά επιτυγχάνει να αποφύγει περισσότερα \texttt{getfield}s.

Καταλήξαμε ότι δεν μπορεί να γίνει ανάλυση και υλοποίηση της μεθόδου αυτής για
δυναμικές γλώσσες χωρίς να λάβουμε υπόψιν μας το aliasing και τις λεπτομέρειες
που επιφέρει. Φυσικά αυτό το πρόβλημα δεν υπάρχει στις στατικές γλώσσες καθώς ο
προγραμματιστής φροντίζει για τους τύπους, ενώ στην περίπτωση μας είναι
αρμοδιότητα του μεταγλωττιστής μας, οπότε το aliasing των τύπων υπεισέρχεται
σχεδόν σε όλη την έκταση των προγραμμάτων.

Μελλοντικές εργασίες περιλαμβάνουν πλήρης υλοποίηση της λογικής των loops
καθώς τώρα η υλοποίησή μας τα αγνοεί κάνοντάς τα όλα να διαφύγουν.