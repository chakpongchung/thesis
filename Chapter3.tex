%------------------------------------------------------------------------------

\chapter{Θεωρία}
\label{chapter3} 

Το κεφάλαιο αυτό θα αναλύσει ότι χρειάζεται να ξέρει ο αναγνώστης για να
κατανοήσει το κεφάλαιο της υλοποίησης. Αρχικά θα περιγράψουμε εκτενέστερα την
διαδικασία που ακολουθείται στο σύστημα RPython για την μεταγλώττιση (π.χ. του
PyPy), έτσι ώστε να ξέρει ο αναγνώστης σε ποιο "χρονικό" σημείο θα λάβει χώρα το
εγχείρημά μας. Έπειτα θα παραθέσουμε με λεπτομέρεια την θεωρία της μεθόδου που
θα υλοποιήσουμε.

%------------------------------------------------------------------------------

\section{Διαδικασία Μεταγλώττισης στο σύστημα RPython}

\subsection{Επισκόπηση}

Ο σκοπός του συστήματος και του \textit{toolchain} του RPython είναι να
μεταφράσει προγράμματα (κυρίως μεταφραστές) γραμμένα σε RPython με
αποτελεσματικότητα ανεξάρτητα με το ποια πλατφόρμα είναι το target του. Το
default target είναι το \textit{C backend} (παραγωγός κώδικα C) και σε αυτό θα
αναφερόμαστε όταν δίνουμε παραδείγματα.

Το σύστημα στην πραγματικότητα δεν βλέπει ποτέ κανονικό κώδικα Python ή
δέντρα, αλλά ξεκινά με \textit{αντικείμενα κώδικα} (code objects) βασισμένα
στις συναρτήσεις που έχουν δοθεί ως είσοδος και τα μετατρέπει με
\textit{abstract interpretation}\cite{CousotCousot77}\cite{debray1995abstract}
σε γραφήματα ροής. Η βασική δηλαδή δομή δεδομένων (unit), πάνω στην οποία
δουλεύει το σύστημα επομένως, είναι τα γραφήματα ροής (σε SSA\cite{ssa} form)
βασισμένα σε function code objects. Ένα γράφημα για κάθε συνάρτηση. Αυτά τα
γραφήματα είναι απλώς ένας ακόμα τρόπος αναπαράστασης του προγράματος, αλλά
πιο κατάλληλος για "αφαιρετικές" εργασίες μεταγλώττισης και βελτιστοποίσης
(π.χ. εξαγωγή τύπων\footnote{βλ. type inference}).

Η διαδικασία είναι οργανωμένη σε στάδια (βλ. Σχήμα \ref{figure-1}).

\begin{enumerate}

\item \textbf{Import \& Flow Analysis}: Εδώ ο αρχικός κώδικας φορτώνεται στην
μνήμη και υφίσταται τις βασικές διαδικασίες συντακικής ανάλυσης. Μετατρέπεται
αρχικά σε tokens, έπειτα σε μια ενδιάμεση μορφή (Python bytecode) – όπως σε
όλους τους μεταγλωττιστές – και τέλος στα διαγράμματα ροής του PyPy. Από αυτό
το στάδιο και έπειτα φυσικά βρίσκεται μόνο μέσα στην τοπική μνήμη, σε μια 
αρκετά "στατική" μορφή για τα δεδομένα του RPython.

\item \textbf{Annotator subsystem}: Εδώ ενεργοποιούνται οι περισσότερο
αφαιρετικές μέθοδοι ερμηνείας του κώδικα. Μια καθολική ανάλυση, που θα 
ξεκινήσει από το σημείο εισόδου του κάθε διαγράματος (entry point), θα "εξάγει"
γενικές πληροφορίες για τον κώδικα και θα συμπεράνει τους τύπους που μπορεί η 
κάθε μεταβλητή να φιλοξενήσει κατά το runtime βάσει φυσικά των συμφραζομένων.
Μετά από αυτό το βήμα, έχουμε annotated flow graphs.

\item \textbf{RTyper}: Αυτό το σύστημα χρησιμοποιεί τους
\textit{υποσημειώμένους} είδικούς προσωρινούς τύπους που έχει προσθέσει ο
annotator για να μετατρέψει τα statements και τις εντολές στα γραφήματα σε
εντολές χαμηλότερου επιπέδου. Είναι ουσιαστικά μια γέφυρα μεταξύ των γραφημάτων
και των παραγωγών κώδικα.

\item \textbf{Optimizations}: Η βελτιστοποίηση στο PyPy γίνεται εδώ. Το project
περιλαμβάνει – και εφαρμόζει –  μια πληθώρα βελτιστοποιήσεων, όπως αυτά που
αναφέραμε στο κεφάλαιο \ref{chapter2}. Επίσης το δικό μας module θα λάβει χώρα
εδώ.

\item \textbf{Προετοιμασία Γραφημάτων}: Εδώ γίνονται οι τελικές ενέργειες πριν
την παραγωγή κώδικα. Τα γραφήματα εδώ λ.χ. υφίσταντο ανάλυση για τον υπολογισμό
ονομάτων μεταβλητών (για λόγους όπως debugging) κ.α. Σημαντικότερες όμως είναι
οι εξής ενέργειες:

\begin{itemize}

\item \textbf{Exception transformer}: Ο "μετατροπέας εξαιρέσεων" ενεργοποιείται
σε αυτό το σημείο και θα εισάγει τον απαραίτητο κώδικα για τη διαχείριση των
εξαιρέσεων που τυχαίνει να υπάρχουν.

\item \textbf{Garbage Collection Transformer}: Εδώ παίρνει σειρά το ειδικό
εργαλείο διαχείρισης "σκουπιδιών μνήμης". Αυτό εκτελεί όποιες ενέργειες
χρειάζονται για την σωστή διαχείριση μνήμης. Αφού η Python είναι πλήρως 
δυναμική γλώσσα και δεν απαιτεί από τον προγραμματιστή να διαχειρίζεται την 
μνήμη που χρειάζεται μόνος του, είναι απαραίτητη η ύπαρξη ενός υποσυστήματος
διαχείρισης σκουπιδιών μνήμης.

\end{itemize}

\item \textbf{Code Generation}: Εδώ τα ήδη μαρκαρισμένα, σημειωμένα,
βελτιστοποιημένα γραφήματα θα μετατραπούν σε κώδικα μηχανής. Εδώ υπάρχουν 
πολλοί "γεννήτορες" κώδικα ανάλογα με τις ανάγκες. Ο βασικότερος και ο πιο 
σημαντικός είναι ο παραγωγός κώδικα C. Αρχικά, τα γραφήματα θα μετατραπούν σε 
άλλα αντίστοιχα, ανάλογα με τον γεννήτορα και έπειτα αυτά θα μετατραπούν σε
κώδικα ανάλογα με την επιλογή (π.χ σε κώδικα C)

\item Τέλος ο κώδικας αυτός θα οδηγηθεί στον μεταφραστή της εκάστοτε επιλογής
(π.χ. \texttt{gcc}) για να παραχθεί το εκτελέσιμο αρχείο.

\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{diagram.png}
\caption{diagram of RPython translation process}
\label{figure-1}
\end{figure}

\subsection{Γραφήματα Ροής}

\subsubsection{Τρόπος δημιουργίας}

Ο σκοπός του κατασκευαστή γραφημάτων (υλοποιημένος στο module
\texttt{rpython.flowspace}) είναι να μετατρέψει τα αντικείμενα συναρτήσεων σε
γραφήματα. Κανονικά οι μεταγλωττιστές παίρνουν μια συνάρτηση και την
μετατρέπουν σε ενδιάμεσο bytecode κώδικα σε κάποια εικονική μηχανή (VM) και
έπειτα την τρέχουν. Στο RPython όμως χρησιμοποιείται ένα \textit{abstract
interpretation} το οποίο λειτουργώντας αφαιρετικά μετατρέπει τον ενδιάμεσο
κώδικα στα βασικα \texttt{Block}, τα οποία περιέχουν όλες τις εντολές οι
οποίες επιδρούν πάνω σε αντικείμενα Python. Το αποτέλεσμα της κάθε εντολής
αποθηκεύεται προσωρινά σε μια μεταβλητή η οποία μπορεί να χρησιμοποιηθεί στις
επόμενες. Για ένα παράδειγμα βλ. Σχήμα \ref{figure-2} το οποίο είναι ένα
γράφημα μιας απλής συνάρτησης με ένα if branch. Φαίνεται η γενική εικόνα των
γραφημάτων, το branch καθώς ο τρόπος που επαναχρησιμοποιούνται οι προσωρινές
μεταβλητές αποτελεσμάτων ανάλογα με τις ανάγκες.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{simple-func-bef.png}
\caption{simple function flow diagram}
\label{figure-2}
\end{figure}

Ο κατασκευαστής "κλείνει" ένα \texttt{Block} και πάει στο επόμενο σε 2 
περιπτώσεις:

\begin{enumerate}

\item Περίπτωση κλήσης \texttt{is\_true()}. Όταν συμβαίνει αυτό, ο \textit{
abstract interpreter} δεν ξέρει φυσικά αν η συνθήκη θα είναι \textit{True} ή
\textit{False} - αφού η γλώσσα μας είναι δυναμική – οπότε θα πρέπει να τις 
ακολουθήσει και τις 2, δημιουργώντας αντίστοιχα άλλες ροές (δηλαδή
\texttt{Blocks}) για την κάθεμια.

\item Περίπτωση εμφάνισης \textit{joinpoint}. Αυτή η περίπτωση λαμβάνει χώρα
όταν η επόμενη εντολή, που πρόκειται να καταγράψουμε στο τρέχον \texttt{Block},
έχει ήδη καταγραφεί ή καταγράφεται τώρα από άλλο \texttt{Block}. Αυτό σημαίνει
ότι ο μεταγλωττιστής έχει κλείσει κάποιον βρόγχο και πρόκειται να μεταγλωττίσει
κώδικα τον οποίο έχει ήδη "δει". Τότε ο μεταγλωττιστής σταματά, και
δημιουργείται ένα \texttt{Link} απο το τρέχον \texttt{Block} στο προηγούμενο,
έτσι ώστε να κλείσει ο βρόγχος και στο διάγραμμα και να υπάρχει πιστή
αναπαράσταση του κώδικα.

\end{enumerate}

\subsubsection{Το μοντέλο}

Η βασική συνάρτηση που δημιουργεί τις δομές δεδομένων που απαρτίζουν το μοντέλο
είναι η \texttt{build\_flow()}. Η μονάδα (unit) ροής είναι το αντικείμενο
\texttt{FunctionGraph} το οποίο μαζί με τα υπόλοιπα (που συνήθως περιέχονται σε
αυτό) ορίζονται στο αρχείο \texttt{rpython/flowspace/model.py}. Τα περιγράφουμε
παρακάτω:

\begin{itemize}

\item \texttt{FunctionGraph} Το διάγραμμα ροής μια συνάρτησης. Είναι η βασική
δομή δεδομένων του μεταγλωττιστή. Περιέχει αναφορές και μια λίστα απο
\texttt{Blocks}, τα οποία συνδέονται με \texttt{Links}. Βασικά κομμάτια του
είναι:

\begin{enumerate}
\item \textbf{startblock:} Το πρώτο block του γραφήματος. Είναι το σημείο
εισόδου για την ροή του προγράμματος όταν αυτή φτάσει σε αυτή την συνάρτηση. Οι
παράμετροι εισόδου θα δοθούν σε αυτό το block. Αυτό το block θα δείχνει όπως
και όλα τα άλλα σε επόμενα ανάλογα με την ροή.
\item \textbf{returnblock:} Το μοναδικό block στο κάθε γράφημα που μπορεί να
εκτελέσει μια "επιστροφή" της συνάρτησης στην ροή του ανώτερου επίπεδου
(function return). Είναι πάντα άδειο και δεν περιέχει ούτε την εντολής
επιστροφής – αυτή υπονοείται. Τα links δείχνουν εδώ όταν και μόνο όταν θέλουν
να τερματίσουν την συνάρτηση. Η μοναδική παράμετρος είναι η τιμή επιστροφής.
\item \textbf{exceptblock:} Αυτό και το παραπάνω είναι τα μόνα blocks που
μπορούν να τερματίσουν την ροή. Είναι το μοναδικό block που μπορεί να
"πυροδοτήσει" μια εξαίρεση. Δέχεται 2 τιμές· η πρώτη είναι η κλάση της εξαίρεσης
και η δεύτερη η τιμής της. Η μόνη περίπτωση να υπάρχει link προς αυτό το block
είναι η ρητή πυροδότηση εξαίρεσης από το πρόγραμμα.
\end{enumerate}

\item \texttt{Block} Το πιο σημαντικό κομμάτι ενός γραφήματος. Ένα γράφημα
ουσιαστικά είναι μια λίστα από blocks. Ένα block περιέχει μια λίστα από
\texttt{SpaceOperation}s, δηλαδή μια λίστα από εντολές. Λεπτομερειακά
αποτελείται από:

\begin{enumerate}
\item \textbf{inputargs:} Είναι μια λίστα με όλες τις μεταβλητές (με καινούργια
ονόματα) που μπορούν να εισέλθουν στο block από οποιοδήποτε προηγούμενο. Η
αντιστοίχηση των παλιών ονομάτων που υπάρχουν στα links με τα καινούργια 
γίνεται ένα προς ένα (π.χ. η πρώτη στα link με την πρώτη στη λίστα).
\item \textbf{operations:} Η λίστα με τις εντολές που θα τρέξουν όταν η ροή
καταλήξει σε αυτό το block. Θα τρέξουν όλες σειριακά χωρίς εξαιρέσεις. Οι
εντολές υποδεικνύονται από \texttt{SpaceOperation}s (βλ. πιο κάτω).
\item \textbf{exits:} Λίστα με πιθανά \textit{άλματα} (jumps). Φυσικά περιέχει
links. Σε "συνεργασία" με το επόμενο μέλος καθορίζει που θα προχωρήσει η ροή 
του προγράμματος. Φυσικά περιέχει ένα ή περισσότερα links.
\item \textbf{exitswitch:} Τα περιεχόμενα αυτού του μέλους ποικίλλουν:

\begin{enumerate}
\item Δεν υπάρχει \textit{jump} και περιέχει \texttt{None}. Το \textit{exits}
περιέχει ένα link.
\item Άλμα υπό συνθήκη. Σε αυτή την περίπτωση το \textit{exitswitch} είναι μια
από τις μεταβλητές του block. Σε συνεργασία με ένα αντίστοιχο
\textit{exitcase} στα \texttt{Link}s, διευθετεί τις περιπτώσεις των branches.
Η ροή θα ακολουθήσει το \texttt{Link}, του οποίου το \textit{exitcase},
ταιριάζει με το \textit{exitswitch} του \texttt{Block}. Αν δεν υπάρχει 
ταίριασμα τότε έχουμε runtime error.
\item Εξαίρεση. Το \textit{exitswitch} περιέχει
\texttt{Constant(last\_exception)}. Το πρώτο \texttt{Link} του \textit{exits}
περιέχει \texttt{None} στο \textit{exitcase} του για την περίπτωση που δεν
υπάρχει εξαίρεση. Τα υπόλοιπα links δείχνουν στα διάφορα classes των εξαιρέσεων
και ακολουθούνται αντίστοιχα. Φυσικά με αυτόν τον τρόπο "προστατεύτεται" μόνο η
τελευταία εντολή.
\item Επιστροφή. Περίπτωση \textit{Returnblock}. Το \textit{exitswitch}
και το \textit{operations} είναι άδεια και το \textit{exits} είναι ρυθμισμένο 
σε \texttt{None}.
\end{enumerate}

\end{enumerate}

\item \texttt{Link} Αποτελεί την σύνδεση μεταξύ των Blocks. Περιέχει:

\begin{enumerate}
\item \textbf{prevblock:} Το προηγούμενο \texttt{Block} από το οποίο δείχνει 
αυτό το \texttt{Link}.
\item \textbf{target:} Το \texttt{Block} στο οποίο δείχνει. Μπορεί να είναι 
μόνο ένα. Αν το \texttt{Block} πρέπει να δείξει σε περισσότερα, τότε πρέπει να 
υπάρχουν πολλά \texttt{Link}s.
\item \textbf{args:} Λίστα με \texttt{Variable}s και \texttt{Constant}s. Βλ. 
παραπάνω.
\item \textbf{exitcase:} Βλ. παραπάνω.
\item \textbf{last\_exception:} Εδώ θα τοποθετηθεί (στο runtime) η κλάση 
εξαίρεσης σε τέτοια περίπτωση, αν το \texttt{Link} δείχνει σε \texttt{Block} 
εξαιρέσεων.
\item \textbf{last\_exc\_value:} Ομοίως εδώ θα τοποθετηθεί η τιμή.
\end{enumerate}

\item \texttt{SpaceOperation} Υποδεικνύει μια "εντολή". Είτε καταγεγραμμένη 
είτε δημιουργημένη από τον ίδιο τον μεταφραστή. Σε αυτό το σημείο οι εντολές 
είναι σχετικά περιορισμένες (λ.χ. δεν μπορούν να πυροδοτήσουν μια εξαίρεση).
Αυτό σημαίνει ότι ο μεταφραστής μπορεί να υποθέσει ότι είναι ασφαλείς και να
εκτελέσει ενεργειες (όπως ανάγνωση μνήμης) που σε άλλες περιπτώσεις θα
απαιτούσαν π.χ. locking. Υπάρχουν 2 πιθανές εξαιρέσεις σε αυτό το σενάριο.

\begin{itemize}
\item η περίπτωση κλήσης άλλης συνάρτησης (βλ. \texttt{simple\_call()})
\item η τελευταία εντολή σε ένα \texttt{Block} χειρισμού εξαιρέσεων μπορεί να
μην είναι ασφαλής.
\end{itemize}

Περιέχει:

\begin{enumerate}

\item \textbf{opname:} Το όνομα της εντολής. Η λίστα με τις εντόλες βρίσκεται 
στο αρχείο \texttt{rpython.flowspace.operation}.
\item \textbf{args:} Τα ορίσματα της εντολής. Μπορεί να είναι \texttt{Constant}
ή \texttt{Variable} αλλά να περιέχεται στο Block.
\item \textbf{result:} καινούργια μεταβλητή στην οποία θα αποθηκευτεί το 
αποτέλεσμα.
\end{enumerate}

\item \texttt{Variable} Αποτελεί ένα placeholder και θα αποκτήσει τιμή κατά το
runtime. Μπορεί προφανώς να είναι όρισμα σε κάποια εντολή. Περιέχονται κάποια 
μέλη με σκοπούς debugging.

\begin{enumerate}
\item \textbf{name:} Εγγυημένα μοναδικό όνομα. Δεν ταιριάζει φυσικά με το 
όνομα που έχει η μεταβλητή στον κώδικα του χρήστη.
\end{enumerate}

\item \texttt{Constant} Αποτελεί την αναπαράσταση μιας σταθεράς. Όπως και 
παραπάνω μπορεί να είναι όρισμα σε κάποια εντολή, ή να βρίσκεται στην λίστα 
κάποιου Link για την αρχικοποίηση των μεταβλητών του επόμενου Block.

\begin{enumerate}
\item \textbf{value:}
\item \textbf{key:} hashed\footnote{βλ. hash function} αντικείμενο που 
αντιπροσωπεύει την τιμή του \textit{value}, για λόγους ασφάλειας κ.α.
\end{enumerate}

\end{itemize}

\subsection{Πέρασμα Υποσημειώσεων – Annotation Pass}

Αυτό το υποσύστημα "υποσημειώνει" τα γραφήματα με ειδικές πληροφορίες
(υπογραφές) έτσι ώστε τα επόμενα υποσυστήματα να γνωρίζουν τους εκάστοτε τύπους
των μεταβλητών και των αντικειμένων. Μπορούμε να πούμε ότι είναι ένα είδος
\textit{type inference}. Μία από αυτές τις υπογραφές για τις μεταβλητές, που θα
υποσημειωθούν, θα περιγράφει όλους τις πιθανούς τύπους που θα είναι δυνατόν να
περιέχει η μεταβλητή αυτή κατά την διάρκεια του runtime. Η ανάλυση/πέρασμα
γίνεται ανά συνάρτηση-γράφημα. Το αποτέλεσμα είναι ένα μεγάλο dictionary που
"δείχνει" από μεταβλητές σε τέτοιες υπογραφές.

Η υπογραφή είναι ένα "στιγμιότυπο" (\textit{instance}) μιας υποκλάσης ενός
\texttt{SomeObject} αντικειμένου. Κάθε υποκλάση αντιπροσωπεύει και μια άλλη
οικογένεια αντικειμένων. Η κλάση βάσης, όπως είπαμε, είναι η
\texttt{SomeObject}, η οποία αντιπροσωπεύει ένα αντικείμενο Python. Υποκλάσεις
της είναι – μεταξύ άλλων – οι: \texttt{SomeInteger()} (με την επιλογή
\texttt{nonneg=True} ανάλογα άν χρειάζονται αρνητικοί αριθμοί),
\texttt{SomeString()}, \texttt{SomeChar()} και \texttt{SomeTuple()}, οι οποίοι
αντιπροσωπεύουν τα προφανή αντικείμενα. Να σημειώσουμε εδώ ότι όλα τα παραπάνω 
αντικείμενα υπογραφών είναι αμετάβλητα, δηλαδή δεν αλλάζουν \textit{in-place}. 
Αυτό σημαίνει ότι εάν ο Annotator αποφασίσει να αλλάξει την υπογραφή, θα 
πρέπει να δημιουργήσει ένα καινούργιο αντικείμενο.

Υπάρχουν αντικείμενα βέβαια τα οποία είναι μεταβλητά, καθώς και αυτά που
αντιπροσωπεύουν χρήζουν προσοχής και ειδικής μεταχείρησης. Σε αυτά, οι 
πληροφορίες μεταβάλλονται καθ όλη την διάρκεια του annotation pass.
Περιλαμβάνουν το \texttt{SomeList()} και το \texttt{SomeDict()}.

Οι πιο εξειδικευμένες περιπτώσεις έχουν να κάνουν με κλάσεις ορισμένες από τον
χρήστη (\textit{user-defined classes}). Το σύστημα τις διαχειρίζεται με το
\texttt{SomeInstance}. Για κάθε τέτοια κλάση διατηρούμε ένα \textit{ClassDef},
που ουσιαστικά περιέχει τα ορίσματα και τα στοιχεία (attibutes) της κλάσης αυτής
σε επίπεδο ορίσματος (class level attibutes) και στιγμιότυπου (instance level
attibutes). Τα τελευταία "ανακαλύπτονται" προοδευτικά καθώς ο μεταγλωττιστής
προχωρεί κατά μήκος του κώδικα. Για παράδειγμα, το παρακάτω θα μεταβάλει το
\textit{ClassDef} του στιγμιότυπου με το attribute.

\begin{verbatim}
inst.attr = value
\end{verbatim}

Η διαφορές μεταξύ των επιπέδων class και των instance είναι λίγες και λεπτές.
Γενικά τα attibutes των class-level χρησιμοποιούνται ως αρχικοποιητές για τα
αντίστοιχα των instance-level\footnote{Το ίδιο ισχύει και για (μεταβλητές που
περιέχουν) συναρτήσεις.}. Για κάθε attribute σημειώνονται οι θέσεις που
λαμβάνουν χώρα αναγνώσεις και έπειτα, κατά την ανάλυση, αν υπάρχει γενικοποίηση
του attribute για κάποιο λόγο, ο μεταγλωττιστής επιστρέφει σε αυτά τα σημεία και
τα μεταβάλει ανάλογα, κάνοντάς τα \textit{valid} ξανά.

\subsection{RTyper}

Ο RTyper είναι μια γέφυρα μεταξύ του Annotator και των παραγωγών κώδικα. Είναι
απαραίτητος γιατί ο Annotator υποσημειώνει τον κώδικα με \textit{υπογραφές}
τύπων είτε δημιουργημένους από τον χρήση\footnote{user-defined classes} είτε
πολύ κοντά στο υψηλό επίπεδο της RPython. Οπότε – για να μπορούμε να παράγουμε
κώδικα – απαιτείται η υποσημείωση των γραφημάτων για το επίπεδο της γλώσσας
στόχου, δηλαδή χαμηλού επιπέδου με δείκτες και arrays. Ο RTyper αναλαμβάνει να
αποφανθεί για τον τύπο και να αντικαταστήσει τις εντολές υψηλού επιπέδου με
άλλες αντίστοιχες χαμηλότερου επιπέδου στα γραφήματα. Προφανώς η αντιστοιχία
δεν είναι 1 προς 1, και μερικές φορές απαιτούνται πολύ περισσότερες εντολές στο
χαμηλό επίπεδο για να μιμηθούμε τις αντίστοιχες του υψηλού. Επιπλέον οι
διαθέσιμες εντολές και οι τύποι είναι σαφώς περιορισμένοι. Τελος, πρέπει να
σημειωθεί ότι αυτό το βήμα θα μπορούσε να μην γίνει, αλλά οι σχεδιαστές έχουν
επιλέξει να είναι ένα αυτόνομο module του συστήματος έτσι ώστε να κάνει την
δουλεία του παραγωγού κώδικα πιο εύκολη και πιο αποδοτική. Μετά το πέρασμα του
RTyper η παραγωγή κώδικα είναι σχετικά τετριμμένη.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Προετοιμασία}

\subsubsection{Διαχείριση Μνήμης}

Αφού η Python είναι δυναμική ενώ οι περισσότερες από τις γλώσσες παραγωγών
(compiled target languages) δεν είναι· θα πρέπει το σύστημα να κάνει κάποιες
επιλογές για την διαχείριση της μνήμης. Αυτές οι επιλογές είναι εξαιρετικά
σημαντικές για την τελική ταχύτητα των προγραμμάτων καθώς γενικά ο κώδικας
Python τείνει να δεσμεύει μνήμη με πολύ γρήγορους ρυθμούς. Το σύστημα είναι
ευέλικτο και υπάρχουν πολλές επιλογές. Δεν θα μπούμε σε επιπλέον πληροφορίες
γιατί είναι έξω από τα όρια σκοπού της εργασίας αυτής, αλλά πληροφοριακά
υπάρχουν:

\begin{itemize}
\item reference counting (απαρχαιωμένο – δεν χρησιμοποιείται πλέον στο σύστημα)
\item ένας συντηρητικός BDW (B\"ohm-Demers-Weiser) συλλέκτης\cite{bdw}
\item πλέον χρησιμοποιούνται άλλοι custom συλλέκτες (βλ. \cite{gc}).
\end{itemize}

\subsubsection{Διαχείριση Εξαιρέσεων}

Ο κώδικας RPython υποστηρίζει πλήρως συντακτικό εξαιρέσεων ακριβώς όπως και η
κανονική Python. Όπως και πριν βέβαια οι γλώσσες παραγωγών δεν "γνωρίζουν" την
έννοια των εξαιρέσεων οπότε ο απαραίτητος κώδικας διαχείρισης θα πρέπει να
προστεθεί. Το σύστημα δουλεύει όπως το κανονικό σύστημα της Python στον
μεταγλωττιστή CPython: οι εξαιρέσεις υποδεικνύονται με ειδικές τιμές επιστροφής
(return values) και η τρέχουσα εξαίρεση αποθηκεύεται σε μια καθολική (global)
δομή δεδομένων, ορατή από όλα τα πεδία δράσης (scope) του προγράμματος.

%------------------------------------------------------------------------------

\pagebreak
\section{Θεωρία Μερικής Ανάλυσης Διαφυγής}

\subsection{Εισαγωγικά}

Αρχικά να σημειώσουμε, ότι η Θεωρία που παραθέτουμε εδώ είναι βασισμένη κυρίως
στο paper των W{\"u}rthinger et al\cite{stadler2014partial} αλλά και σε επιπλέον
έρευνα και εμπειρία που αποκτήσαμε κατά την υλοποίηση του module. Η μέθοδος,
λοιπόν, που θα προσπαθίσουμε να υλοποιήσουμε στο module μας λέγεται
\textit{Μερική Ανάλυση Διαφυγής} (\textit{Partial Escape Analysis}) και είναι
μια γενίκευση της κανονικής "Απλής" Ανάλυσης Διαφυγής. Σκοπός μας είναι προφανώς
η βελτιστοποίηση των προγραμμάτων και για να το πετύχουμε αυτό στοχεύουμε στο να
μειώσουμε τον αριθμό των μεταβλητών που χρησιμοποιεί ο χρήστης, και τον αριθμό
των προσβάσεων (\textit{accesses}) που κάνει στην μνήμη για αυτές.

Η πιο προφανής βελτιστοποίηση με βάση αυτή την ανάλυση είναι η πλήρης εξάλειψη
των δεικτών που δεν διαφεύγουν ή η αντικατάστασή τους με βαθμωτούς μέσα στο
δυναμικό τους πεδίο. Επίσης δυνατή είναι η αντικατάσταση καταχωρήσεων μνήμης
(malloc) στον σωρό (heap) με απλές κατωχηρώσεις στη στοίβα (stack) πράγμα που
κάνει το πρόγραμμα πολύ πιο γρήγορο, και στην περίπτωση γλώσσας με σύστημα
"συλλογής απορριμμάτων" αυτό οδηγεί στο τρέξιμο του συλλέκτη λιγότερες φορές.
Τέλος μπορούμε να έχουμε κάποια οφέλη στα συστήματα συγχρονισμού. Αν ο δείκτης
βρεθεί να μπορεί να προσπελαστεί μόνο από ένα νήμα, τότε μπορούμε να 
αφαιρέσουμε τις δομές συγχρονισμού. Εμείς θα ασχοληθούμε μόνο με αντικατάσταση 
βαθμωτών.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< MOAR

%------------------------------------------------------------------------------

\subsection{Η Απλή Ανάλυση}

Για να πετύχουμε τα παραπάνω αρκεί να "αναλύσουμε" τις μεταβλητές μια-μια και
να καθορίσουμε όλα τα μέρη όπου μια μεταβλητή\footnote{Δηλαδή ένας δείκτης σε
μια θέση μνήμης. Χρησιμοποιούμε τους όρους "μεταβλητή" και "δέικτης"
εναλλακτικά.} απαιτείται να υπάρχει καθώς επίσης και το αν η διάρκεια ζωής της
μπορεί να αποδειχθεί να περιορίζεται μόνο στην τρέχουσα διαδικασία και/ή
νήμα\footnote{\textit{thread}}, δηλαδή το \textit{scope}.

Με άλλα λόγια, η \textit{Ανάλυση Διαφυγής} είναι μια μέθοδος για τον καθορισμό
του \textit{δυναμικού πεδίου} των δεικτών ενός προγράμματος. Την περιοχή δηλαδή,
στην οποία οι δείκτες αυτοί είναι ενεργοί και έγκυροι ή αλλιώς την περιοχή που
μπορεί το πρόγραμμα να έχει "πρόσβαση" σε αυτούς. Πιο συγκεκριμένα η
\textit{Ανάλυση Διαφυγής} ελέγχει εάν ένα (δεσμευμένο από το σύστημα)
αντικείμενο \textit{διαφεύγει} από αυτό το scope.

Ένας δείκτης που δημιουργείται από κάποια συνάρτηση – δηλαδή ένα
\textit{reference} σε ένα αντικείμενο (της Python) – μπορεί να \textit{διαφύγει}
σε κάποια άλλη. Τότε το δυναμικό του πεδίο μεγαλώνει. Ένας δείκτης λέμε ότι έχει
\textit{διαφύγει} όταν αυτός είναι διαθέσιμος (ή αλλιώς ορατός) και από άλλα
scopes στο πρόγραμμα, οπότε \textbf{απαιτείται} να υπάρχει αυτός καθ'αυτός. Ο
σημαντικότερος τρόπος για διαφυγή είναι η επιστροφή του αντικειμένου ως return
value μιας συνάρτησης. Θα δούμε αναλυτικά και άλλους τρόπους στο επόμενο
κεφάλαιο απλά να σημειώσουμε ότι υπάρχουν και άλλοι πιο περίπλοκοι τρόποι
διαφυγής όπως στην περίπτωση functional γλωσσών και tail-call optimization, όμως
δε θα ασχοληθούμε με αυτές σε αυτή την εργασία.

Ως ιστορική σημείωση να πούμε ότι παλαιότερα οι μέθοδοι αναλύσης διαφυγής
χρησιμοποιούσαν αλγόριθμους που ονομάζονται "Equi-Escape
Sets"\cite{kotzmann2005escape} για να αποφανθούν εάν τα αντικείμενα διαφεύγουν
του τρέχοντος scope. Δημιουργούσαν σύνολα (sets) από αντικείμενα που ανήκουν
στην ίδια κατηγορία διαφυγής, έπειτα με το να αναλύουν τις μεθόδους και τις
συναρτήσεις, μπορούσαν να μαρκάρουν τα διάφορα αντικείμενα και σύνολα (π.χ. αν
το αντικείμενο από το ένα σύνολο αναθέτονταν σε ένα άλλο σύνολο) και να τα
συγχωνεύσουν.\cite{stadler2014partial}

Τα αποτελέσματα που θα επιστρέψουμε θα χρησιμοποιηθούν για να τροποποιηθεί ο
κώδικας με βέλτιστο τρόπο. Παρακάτω θα παραθέσουμε ένα παράδειγμα για τον τρόπο
με τον οποίο ο βελτιστοποιητής μας θα μετατρέψει ένα κομμάτι κώδικα. Να
υπογραμμίσουμε εδώ ότι το παράδειγμα είναι από το paper, τροποποιημένο όμως με
τέτοιο τρόπο έτσι ώστε να είναι σχεδιασμένο φυσικά για Python και να αναδεικνύει
τις δυνατότητες και λεπτομέρειες της γλώσσας.

\begin{lstlisting}[language=Python]
class Key(object):
    def __init__(self, idx, ref):
        self.idx = idx
        self.ref = ref
    def equals(self, other):
        return (self.idx == other.idx && self.ref == other.ref)

def createValue(...):
    ...
        
cacheKey = None
cacheValue = None

def getValue(idx, ref):
    key = Key(idx, ref)
    if key.equals(cachekey):
        return cacheValue
    else:
        return createValue(...)
\end{lstlisting}

Το παραπάνω κομμάτι (μετά από ανάλυση διαφυγής και inlining – που εφαρμόζεται
από το PyPy) θα γίνει κάπως έτσι:

\begin{lstlisting}[language=Python]
...
def getValue(idx, ref):
    idx1 = idx
    ref1 = ref
    tmp = cacheKey
    if (idx1 == tmp.idx && ref1 == tmp.ref):
        return cacheValue
    else:
        return createValue(...);
...

\end{lstlisting}

Αυτό που θα αλλάξει εδώ είναι η συνάρτηση \texttt{getValue()} κατά το
compilation της. Όταν ο μεταγλωττιστής φτάσει σε αυτή, θα καταλήξει στο
συμπέρασμα ότι κανένα reference στο δεσμευμένο αντικείμενο \texttt{Key} δεν
διαφεύγει από το τρέχων compilation scope της συνάρτησης. Αυτό σημαίνει ότι
κανένα reference δεν θα υπάρχει αφού τερματίσει και επιστρέψει η συνάρτηση και
ότι κανένα άλλο αντικείμενο ή κατασκευή ή συνάρτηση δεν θα "θέλει" να αναφερθεί
σε αυτό. Οπότε, μπορούμε να τροποποιήσουμε τον κώδικα με τους παρακάτω τρόπους:

\begin{itemize}

\item Η δέσμευση μνήμης του αντικειμένου στον σωρό (\textit{garbage collected
heap}) μπορεί να αντικατασταθεί με μια απλή δέσμευση στην στοίβα
(\textit{stack}) της συνάρτησης ή σε κάποια άλλη περιοχή ή ζώνη\footnote{Ζώνες
ονομάζονται περιοχές του σωρού (heap) που έχουν ήδη αρχικοποιηθεί και έχουν
περιορισμένη διάρκεια ζωής με σκοπό αυτό ακριβώς το είδος χρήσης.} η οποία δεν
υπόκειται συλλογή απορριμάτων. Αυτό σημαίνει ότι μια κανονική δέσμευση (με την
εντολή \textit{malloc}), που θα έχει μεγάλη διάρκεια ζωής και θα είναι ακριβή
και στην αρχικοποίηση και στον καθαρισμό της, μπορεί να μεταβληθεί σε μια απλή
προσωρινή μεταβλητή στην συνάρτηση που μετά το πέρας του runtime της, θα
ελευθερωθεί. Αυτό μας εξοικονομεί και χρόνο (σε δύο περιπτώσεις –
\textit{allocation} και \textit{freeing}) και μνήμη.

\item \textit{Αντικατάσταση Βαθμωτών} Εκτός από το παραπάνω μπορούμε
να προχωρήσουμε σε αντικατάσταση με βαθμωτούς. Αυτό θα εξαλείψει τελείως την
δέσμευση, με το να αντικαταστήσει τα fields του αντικειμένου με τοπικές
μεταβλητές.

\end{itemize}

Βλέπουμε ότι η δέσμευση του αντικειμένου \texttt{Key} αντικαταστήθηκε με τις
τοπικές μεταβλητές \texttt{idx1} και \texttt{ref1}. Αν και αυτό είναι
εξιδανικευμένο παράδειγμα, μπορούμε να περιμένουμε πολλές τέτοιες βελτιώσεις
ακόμα και σε \textit{real-world} κομμάτια κώδικα και βιβλιοθήκες, όπως θα δούμε
στο τελευταίο κεφάλαιο.

Επίσης σημαντική αλλαγή είναι το inlining που πραγματοποιήθηκε στον κώδικα, και
αυτό ήταν ζωτικό στο να μπορέσει η ανάλυσή μας να "εξάγει" το σωστό αποτέλεσμα
για τις μεταβλητές. Σε αντίθετη περίπτωση η "μονή" χρήση του αντικειμένου (του
\texttt{Key}) θα είχε ουσιαστικά κρυφτεί πίσω από μια κλήση στην μέθοδο του
αντικειμένου.

Σημειώνουμε ότι  το παραπάνω είναι κανονικός κώδικας Python – ελλιπής βέβαια και
δεν μπορεί να τρέξει – για παιδαγωγικούς σκοπούς. Για παράδειγμα δεν παραθέτουμε
τον ορισμό της συνάρτηση \texttt{createValue()} που προφανώς είναι η "ακριβή"
συνάρτηση που δημιουργεί το αντικείμενο που θέλουμε να αποφύγουμε (βλ. γραμμές
8-9 και 19). Όσων αφορά το δεύτερο βελτιστοποιημένο κομμάτι, δεν παραθέτουμε
καθόλου την κλάση \texttt{Key()} και δεν δίνουμε το τι περιέχουν οι καθολικές
μεταβλητές (βλ. γραμμή 5). Ο αναγνώστης αρκεί να ξέρει ότι προσπαθούμε να
αποφύγουμε την δέσμευση και χρήση μνήμης. Να υπογραμμίσουμε επίσης ότι, στην
πραγματικότητα ο βελτιστοποιητής μας δεν αλλάζει – ούτε παράγει – κώδικα Python,
αλλά middleware κώδικα, και δουλεύει πάνω σε διαγράμματα ροής όπως θα δούμε στα
επόμενα κεφάλαια.

Τέλος να πούμε ότι η απλή ανάλυση διαφυγής είναι ήδη υλοποιημένη στο PyPy στο
αρχείο \texttt{escape.py}, και χρησιμοποιείται κανονικά και αποδοτικά στο
compiling του ίδιου του μεταγλωττιστή καθώς και άλλων προγραμμάτων. Στοχεύουμε
σε τέτοιου intergration του module μας στο σύστημα.

%------------------------------------------------------------------------------

\subsection{Η Μερική Ανάλυση}

Η "Μερική Ανάλυση Διαφυγής" δουλεύει ομοίως με παραπάνω, αλλά είναι πιο ισχυρή
με την έννοια ότι λαμβάνει υπόψιν της και τα διάφορα παρακλάδια (branches) της
ροής εκτέλεσης κατά την ανάλυση. Με άλλα λόγια η κανονική Ανάλυση Διαφυγής
χειρίζεται μια περίπτωση \texttt{if} "στατικά" – ουσιαστικά την αγνοεί, ενώ η
αντίστοιχη μερική ακολουθεί και τις 2 πιθανές ροές. Το γεγονός αυτό όμως
καθιστά την σχεδίαση της υλοποίησης πιο δύσκολη.

Σε πολλές περιπτώσεις το γεγονός ότι η απλή ανάλυση αγνοεί τα \textit{if splits}
και απλά παίρνει καθολικές αποφάσεις, οδηγεί στην ανικανότητα να ανιχνευτεί η
δυνατότητα αφαίρεσης κάποιων αντικειμένων. Για αυτό τον λόγο η μερική ανάλυση, η
οποία μπαίνει στο κάθε branch και το αναλύει ξεχωριστά, θεωρείται ισχυρότερη.
Διατρέχει τον κώδικα με τον ίδιο τρόπο όπως η απλή ανάλυση αλλά διατηρεί
"καταστάσεις" (states) για κάθε branch που έχει γίνει στην ροή και όταν τα
branches συγκλίνουν ξανά, μπορεί να αποφασίσει αν το αντικείμενο διαφεύγει
ανάλογα με το τι συνέβη στο κάθε ένα από αυτά. Οι αποφάσεις αυτές λαμβάνουν χώρα
και για κάθε state ξεχωριστά αλλά το ένα επηρεάζει το άλλο αφού φυσικά ο
μεταγλωττιστής δεν μπορεί να ξέρει ποιο από τα branches θα ακολουθηθεί
πραγματικά.

<<<<<<<<<<<<< εδώ ίσως και άλλη γενική θεωρία και διαφορές. Μηπως complexities?

Θα συνεχίσουμε με κάποιες λεπτομέρειες για τον τρόπο που δουλεύει η μερική
ανάλυση για να εγκλιματιστεί ο αναγνώστης και θα δώσουμε ένα εκτενές παράδειγμα
αργότερα με όλες τις λεπτομέριες.

%------------------------------------------------------------------------------

\subsection{Τρόπος λειτουργείας/ανάλυσης}

Η βελτιστοποίηση αυτή θα κρίνει ποιες μεταβλητές είναι απαραίτητο να
υπάρχουν (π.χ. γιατί βασίζεται κάποιος εξωτερικός παράγωντας σε αυτές) και θα
αποπειραθεί να αφαιρέσει τις υπόλοιπες. Η αφαίρεση θα πρέπει φυσικά να είναι
έξυπνη καθώς η λειτουργία και η ορθότητα του προγράμματος θα πρέπει να
διατηρηθούν. Αυτό επιτυγχάνεται συνήθως με αντικατάσταση βαθμωτών στην θέση της
μεταβλητής.

Οι 2 κυριότεροι λόγοι για να απαιτείται η ύπαρξη της μεταβλητής είναι:
\begin{enumerate}
\item η χρήση της ως τιμή επιστροφής από την συνάρτηση (\textit{return})
\item η αλλαγή του scope της (\textit{globalization})
\end{enumerate} 

Γενικά η μέθοδος, όπως έχουμε πει, σκανάρει το πρόγραμμα και "παρακολουθεί" τις
μεταβλητές και τις κατασκευές του προγραμματιστή. Ξεκινά σειριακά ακολουθόντας
την ροή στο κάθε γράφημα από το πρώτο Block. Καθώς αναλύει το κάθε Block,
διατηρεί κάποιες πληροφορίες για τις μεταβλητές ανάλογα με την εντολή
(operation) που θα συναντήσει. Χρησιμοποιούμε  "εικονικά αντικείμενα"
(\textit{VirtualObjects}), για να αναπαραστήσουμε τις πιθανές μεταβλητές που
μπορεί να είναι "υποψήφιες" για αφαίρεση (αντικατάσταση με βαθμωτούς). Για κάθε
καινούργια μεταβλητή που συναντά δημιουργεί και διατηρεί ένα τέτοιο εικονικό
αντικείμενο, και διαγράφει την ακριβή (σε χρόνο και μνήμη) δέσμευση μέσω μιας
εντολής \texttt{malloc}. Έπειτα σε κάθε "χρήση"\footnote{βλ. ανάγνωση(read) ή
εγγραφή(write) σε αυτή} της μεταβλητής και σε κάθε άλλη εντολή που μπορεί να το
επηρεάσει, το αντικείμενο αυτό μεταβάλλεται. Όταν ο μεταγλωττιστής αντιληφθεί
ότι βρίσκεται σε κάποια από τις περιπτώσεις που η μεταβλητή πρέπει να υπάρχει
(βλ. παραπάνω) τότε διαγράφει το εικονικό αντικείμενο και αντιστρέφει
οποιαδήποτε ενέργεια είχε κάνει.

Τα εικονικά αυτά αντικείμενα περιέχουν όλες τις πληροφορίες που χρειάζεται ο
μεταγλωττιστής για να μιμηθεί τις αντιστοιχες μεταβλητές. Πρώτα απ'όλα περιέχουν
όλα τα object attributes τους, καθώς τα πάντα στην Python είναι αντικείμενα.
Έπειτα μπορούν να περιέχουν πληροφορίες locking και syncing για τις περιπτώσεις
κατανεμημένου κώδικα. Τέλος περιέχουν πληροφορίες για την θέση που βρίσκονταν
καθώς και για τον τρόπο που πρέπει να λάβει χώρα η δέσμευση μνήμης τους (βλ.
τρόπου casting ή π.χ. αν θα γίνει ή όχι χρήση του garbage collector).

Ο αναλυτής μας όμως δεν διατηρεί μόνο τέτοια αντικείμενα και δομές για να τα
αποθηκεύει. Διατηρεί επίσης και ένα σύστημα για να δημιουργεί aliases για τα
αντικείμενα αυτά ανάλογα με τις μετονομάσεις και τα castings που γίνονται στον
κώδικα. Λόγω της υψηλής δυναμικότητας της γλώσσας τα casting βρίθουν και
δυσκολεύουν το έργο της σχεδίασης.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< MOAR

Το σύστημα, για την διαχείριση της πληροφορίας που ακολουθούμε, μπορεί να
περιγραφεί από το σχήμα \ref{figure-6}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{DS-schema.png}
\caption{The Schema of our Data Structures}
\label{figure-6}
\end{figure}

%------------------------------------------------------------------------------

\subsection{Παράδειγμα}

Εδώ παραθέσουμε ένα εκτενές παράδειγμα, αυτή τη φορά φυσικά για τις διαφορές και
λεπτομέρειες της μερικής ανάλυσης με περισσότερη \textit{real-world} λεπτομέρεια
από το αντίστοιχο της απλής ανάλυσης, ακολουθώντας φυσικά το παράδειγμα του
paper\cite{stadler2014partial} εξιδανικευμένο για την Python. Αυτή την φορά ο
αρχικός κώδικας είναι μετά το inlining για να αναδείξουμε καλύτερα τα
αποτελέσματα της ανάλυσης διαφυγής.

\begin{lstlisting}[language=Python]
...
def getValue(idx, ref):
    key = Key()
    key.idx = idx
    key.ref = ref
    tmp1 = cacheKey # getting from a global
    tmp2 = (key.idx == tmp1.idx && key.ref == tmp1.ref)
    if tmp2:
        return cacheValue
    else:
        cacheKey = key # assigning to a global
        cacheValue = createValue(...)
        return cacheValue
...
\end{lstlisting}

Ξανά δεν δίνουμε τις καθολικές (global) μεταβλητές (βλ. γραμμή 5) και πολλές
λεπτομέρειες που θα επιβάρυναν τον κώδικα χωρίς να προσφέρουν επιπλέον
πληροφορία. Αναδεικνύουμε παρακάτω πως θα ήταν σε κώδικα Python η
βελτιστοποιημένη έκδοση του παραπάνω κώδικα. Επαναλαμβάνουμε ότι αυτή η
λειτουργία γίνεται σε γραφήματα ροής.

\begin{lstlisting}[language=Python]
...
def getValue(idx, ref):
    tmp = cacheKey
    if (key.idx == tmp.idx && key.ref == tmp.ref):
        return cacheValue
    else:
        key = Key()
        key.idx = idx
        key.ref = ref
        cacheKey = key
        cacheValue = createValue(...)
        return cacheValue
...
\end{lstlisting}

Βλέπουμε τον τρόπο που ο βελτιστοποιητής άλλαξε τον κώδικάς μας.

\begin{itemize}

\item Στην γραμμή 3 η δέσμευση (η δημιουργία ουσιαστικά του αντικειμένου) έχει
αφαιρεθεί. Δημιουργείται εικονικό αντικείμενο.\footnote{Για περισσότερες
λεπτομέρειες για τα εικονικά αντικείμενα βλ. προηγούμενο κεφάλαιο}

\item Οι αναθέσεις στις γραμμές 4 και 5 έχουν επίσης αφαιρεθεί. Γίνεται
"ανάκλαση" των αποτελεσμάτων τους και των side-effect τους στα εικονικά
αντικείμενα.

\item Οι απόπειρες πρόσβασης σε περιοχές δεσμευμένης μνήμης στην γραμμή 7 έχουν
αντικατασταθεί με απλές προσβάσεις σε τοπικές περιοχές.

\item Στην περίπτωση του \texttt{if} στην γραμμή 8, δημιουργείται ένα επιπλέον
αντίγραφο της δομής δεδομένων που διαχειρίζεται τα εικονικά αντικείμενα
(\textit{state} – βλ. παρακάτω).

\item Στην γραμμή 9 το αντικείμενο είναι ακόμα εικονικό. Λόγω της εντολής
\texttt{return} η διαδικασία ανάλυσης αυτού του branch (του if) τερματίζει εδώ.

\item Η ανάλυση για το δεύτερο branch όμως συνεχίζεται στο \textit{else case}
εδώ. Στην στιγμή της γραμμή 11 το αντικείμενο είναι ακόμα εικονικό όμως λόγω της
ανάθεσης σε καθολική μεταβλητή θα "διαφύγει". Για να μπορεί να γίνει αυτό όμως,
το αντικείμενο θα πρέπει να υπάρχει αυτό καθ' αυτό, οπότε θα πρέπει να
τοποθετηθεί στον κώδικα η δέσμευση της μνήμης, η αρχικοποίησή της, η ανάθεση των
field σύμφωνα με το εικονικό αντικείμενο (και ότι άλλο υπεισέρχεται στην
δημιουργία ενός αντικειμένου). Ονομάζουμε αυτή την διαδικασία
\textit{materialization} (βλ. επόμενο κεφάλαιο).

\item Οι γραμμές 12 και 13 δεν επηρεάζουν πλέον την κατάσταση του κώδικα – αφού
έχουμε ήδη αποφανθεί ότι το αντικείμενο πρέπει να υπάρχει.

\end{itemize}

Γενικά, όπως βλέπουμε, η δέσμευση και όλες οι ακριβές ενέργειες έχουν
τοποθετηθεί ακριβώς εκεί που απαιτούνται και όχι οπουδήποτε αλλού – δηλαδή στο
\textit{else case} του \textit{if branch}. Αυτό προφανώς δεν οδηγεί σε μικρότερο
αριθμό εντολών \texttt{malloc} (ούτε άλλων ακριβών εντολών) αλλά μειώνει τον
δυναμικό αριθμό των δεσμεύσεων μνήμης αφού αυτοί θα συμβούν πιο σπάνια δεδομένου
ότι βρίσκονται σε ένα από τα \textit{cases} και όχι στην κυρίως ροή του κώδικα.
Με άλλα λόγια μειώνουν το μέσο κόστος της συνάρτησης, βασιζόμενοι στην μικρότερη
συχνότητα με την οποία τρέχουν τα \textit{branches}. Όπως θα δούμε στο κεφάλαιο
των μετρήσεων (Κεφ. 5.) αυτό συμβαίνει συχνά.


%------------------------------------------------------------------------------

\subsection{Επιπλέον Λεπτομέρειες – Σχέδιο Υλοποίησης}

Η βελτιστοποίηση με την μέθοδο μερικής διαφυγής φυσικά είναι πολύ πιο αποδοτική
όταν συνδιάζεται με επιπλέον βελτιστοποιήσεις και τροποποιητές του κώδικα όπως
το inlining που είδαμε πιο πάνω. Το \textit{inling} είναι η μεταφορά κομματιών
κώδικα σε άλλα σημεία έτσι ώστε να αποφευχθεί κάποια κλήση συνάρτησης. Ο
μεταγλωττιστής φυσικά προβαίνει σε αυτό όταν αποφανθεί ότι η κλήση αυτή καθ'
αυτή – δηλαδή η δημιουργεία stack και ότι άλλο περιλαμβάνει αυτό – είναι ακριβή
και δεν αξίζει. Οπότε αντί για κλήση σε συνάρτηση θα μεταφέρει τον κώδικα της
συνάρτησης στο σημείο που βρίσκεται η ροή την εκάστοτε στιγμή. Φυσικά πολλές
φορές ο μεταγλωττιστής δεν θα το κάνει – υπάρχει λόγος που πολλές φορές ο
προγραμματιστής αποφασίζει να χρησιμοποιήσει συναρτήσεις\footnote{εκτός από την
ευκολότερη διαχείρηση του κώδικα} όταν π.χ. η κλήση θα συμβεί πολλές φορές. Εαν
προβούμε σε inlining σε αυτή την περίπτωση το μέγεθος του κώδικα θα αυξηθεί
δραματικά. Είναι προφανές ότι αυτού του είδους η ενέργεια βοηθά το δικό μας έργο
σε τεράστιο βαθμό. Οι μεταβλητές που αποφασίζουμε ότι μπορούν να αφαιρεθούν
είναι πολύ περισσότερες μετά το πέρασμα του inliner, καθώς οποιαδήποτε μεταβλητή
μπορεί να μεταφερθεί στην συνάρτηση έχει μεταφερθεί. Ο inliner υλοποιείται στο
αρχείο \texttt{inliner.py}.

Η βελτιστοποίηση με την μέθοδο διαφυγής έχει αποδειχθεί σωστή και παραθέτουμε
την εργασία της απόδειξής της\cite{proof} καθώς και μια ανάλυση της
πολυπλοκότητάς της\cite{complexity}.

Για επιπλέον πρακτικές λεπτομέρειες για το πως υλοποιήσαμε την παραπάνω θεωρία
και  φυσικά ότι λεπτομέρειες πραγματικού περιβάλλοντος αυτό περιείχε βλ.
επόμενο κεφάλαιο.