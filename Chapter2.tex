%------------------------------------------------------------------------------

\chapter{Βελτιστοποίηση δυναμικού κώδικα}
\label{chapter2}

\section{Γενικά}

Η βελτιστοποίηση είναι η διαδικασία κατά την οποία ένα κομμάτι κώδικα
τροποποιείται έτσι ώστε να καταστεί πιο αποτελεσματικό - είτε από άποψη χώρου
είτε από άποψη χρόνου - χωρίς να αλλάξουν τα αποτελέσματα που δίνει ή τα side-
effects που προκαλεί. Ο χρήστης δεν θα πρέπει να αντιληφθεί την αλλαγή και απλά
να δει το πρόγραμμα του να τρέχει πιο γρήγορα και/ή να απαιτεί μικρότερη μνήμη.
Η βελτιστοποίηση κώδικα είναι το κεντρικό θέμα αυτής της εργασίας. Πάνω σε αυτό
το θέμα γίνεται σήμερα το μεγαλύτερο κομμάτι ακαδημαϊκής έρευνας από τα
πανεπιστήμια του κόσμου, καθώς τα υπόλοιπα κομμάτια ενός
μεταφραστή/μεταγλωττιστή θεωρούνται τετριμμένα. Η θεωρία των parsers και των
semitics analyzers για παράδειγμα έχει φτάσει σε ένα τυπικό σημείο κορεσμού, και
η αντίληψη που έχουμε για αυτά είναι σχεδόν ολοκληρωμένη. Από την άλλη η
βελτιστοποίηση κώδικα, παρά το γεγονός ότι μελετάται από τις απαρχές της εποχής
των ηλεκτρονικών υπολογιστών, είναι ακόμα σε πρώιμα στάδια.  Είναι δεδομένο ότι
οι compilers για τις "ώριμες" γλώσσες θα παράγουν σωστό κώδικα αλλά θα κριθούν
σε σχέση με τις άλλες για το πόσο καλό βελτιστοποιημένο κώδικα παράγουν.

Δηλαδή ο κάθε οργανισμός/πανεπιστήμιο/μεταγλωττιστής εκτελεί την βελτιστοποίηση
διαφορετικά. Αυτό γιατί τα περισσότερα προβλήματα βελτιστοποίησης είναι NP-
complete οπότε η πλειοψηφία των αλγόριθμων θα πρέπει να βασιστεί σε ευρετικά και
σε προσεγγίσεις. Είναι πολλές φορές δυνατόν ο ένας αλγόριθμος να παράγει σωστό
και γρήγορο κώδικα σε μια περίπτωση προβλήματος ενώ σε μια παρόμοια, όχι απλά να
μην υπάρχει βελτίωση, αλλά να υπάρχει και απότομη αύξηση χρόνου και/ή μνήμης.
Παρόλα αυτά οι περισσότεροι αλγόριθμοι τείνουν να δουλεύουν καλά για την
πλειοψηφία των προβλημάτων.

Φυσικά η καλύτερη - και έξυπνη - βελτιστοποίηση θα έρθει από την μεριά του
προγραμματιστή. Κανένας αλγόριθμος δεν είναι τόσο εξύπνος ακόμα ώστε να
αντικαταστήσει τον άνθρωπο π.χ. στην επιλογή του κατάλληλου αλγορίθμου για
ταξινόμηση. Με άλλα λόγια, όσων αφορά την ανάλυση πολυπλοκότητας σε big-O (τον
καλύτερο "κριτή" αλγορίθμων που έχουμε), οι αλγόριθμοι βελτιστοποίησης μπορούν
να κάνουν αλλαγές μόνο σε τάξη μεγέθους σταθεράς. Βέβαια αν ο αλγόριθμος είναι
ιδανικός από την πλευρά του "έξυπνου" χρήστη, τότε τέτοιες μικρές βελτιώσεις
μπορούν να κάνουν την διαφορά.

Από την άλλη ο προγραμματιστής θα πρέπει ιδανικά να περιορίζεται στις έξυπνες
επιλογές αλγορίθμου κλπ. και να μην επιχειρεί να βελτιώσει το πρόγραμμα πρόωρα·
κατά την πρώτη δηλαδή φάση της σχεδίασης και υλοποίησης, γιατί όποια τυχόν
βελτιστοποίηση από μέρους του μεταφραστή θα γίνει βάσει ιδιοματικής σύνταξης της
γλώσσας. Με άλλα λόγια, από ένα απλό loop αρχικοποίσης θα παραχθεί πολύ πιο
ποιοτικός κώδικας μηχανής εκ μέρους του μεταφραστή, σε σχέση με κάποιο απόκρυφα
δύσκολο τρόπο αρχικοποίησης, που ο προγραμματιστής επέλεξε επειδή θεώρησε ότι θα
είναι πιο γρήγορος. Στα λόγια του Donald Knuth: \textit{"Premature optimization
is the root of all evil in programming"}.\cite{knuth}

Η βελτιστοποίηση κώδικα δε θα πρέπει φυσικά σε καμία περίπτωση να πειράζει την
ορθότητα του προγράμματος. Θα πρέπει το παραγόμενο βελτιστοποιημένο πρόγραμμα να
αποδίδει τα ίδια αποτελέσματα στον τελικό χρήστη και να παράγει τις ίδιες
"παρενέργειες" (side-effects) σε όλες τις περιπτώσεις και για όλες τις εισόδους.
Σαφώς το πρόγραμμα θα πρέπει να είναι σωστό εκ μέρους του προγραμματιστή για να
μπορεί ο μεταφραστής να εγγυηθεί το παραπάνω.

Σημαντικός είναι ο καθορισμός του πότε είναι δυνατός και πότε απαιτείται η
βελτιστοποίηση. Φυσικά τον τελευταίο λόγο και σε αυτή την περίπτωση τον έχει ο
προγραμματιστής. Όλοι οι μοντέρνοι μεταφραστές έχουν την επιλογή πλήρους
απενεργοποίησης των διαδικασιών βελτιστοποιήσης ενώ πολλοί προσφέρουν και
δυνατότητες επιλογής συγκεκριμένων διαδικασιών (π.χ. μόνο αντικατάσταση
βαθμωτών).

Αξίζει να αναφέρουμε ότι η βελτιστοποίσης βασίζεται σε πολύ μεγάλο βαθμό στην
αρχιτεκτονική του κάθε υπολογιστή και το αποτέλεσμα μπορεί να είναι δραστικά
διαφορετικό όταν μεταφράσουμε για κάποια άλλη αρχιτεκτονική. Οι ώριμοι
μεταφραστές είναι ικανοί να μεταφράσουν για όλες τις σύγχρονες αρχιτεκτονικές.

Χονδρικά η διαδικασία μεταγλώττισης έχει ως εξής: λεξική ανάλυση (lexical
analysis), συντακτική ανάλυση (syntactic analysis), σημαντική ανάλυση
(semantics) όπου αντιστοιχίζονται τα τυχόν token με "ιδιότητες" της γλώσσας
(μέχρι εδώ αντιλαμβάνεται όλα τα συντακτικά λάθη), και έπειτα παραγωγή
intermediate κώδικα. Σε αυτό το σημείο ο κώδικας αυτός θα υποστεί ανάλυση (βλ.
παρακάτω) και θα βελτιωθεί.

%------------------------------------------------------------------------------

\section{Τεχνικές Βελτιστοποίσης}

Οι περισσότερες τεχνικές βελτιστοποίησης βασίζονται σε ανάλυση του
\textit{"control flow"} (ροή) του προγράμματος κατά το runtime (Control flow
analysis) Μέχρι και πριν από το σημείο της ανάλυσης αυτής ο μεταφραστής έχει
μόνο τυπικές πληροφορίες για το τι κάνει το πρόγραμμα που μεταφράζει. Εδώ
βρίσκει περισσότερες "σημαντικές" πληροφορίες για την φύση του προγράμματος με
το να αναλύει την ροή του (δηλαδή τα forks λόγω if, τα loops κ.α.). Φυσικά ποτέ
δεν έχει πλήρη επίγνωση.

Η ανάλυση αυτή γίνεται με το να κατασκευάζεται το \textit{γράφημα ροής} (control
flow graph), το οποίο καταγράφει όλη την ροή δηλαδή όλα τα πιθανά "μονοπάτια"
που είναι δυνατόν να ακολουθήσει το πρόγραμμα. Το βασικό στοιχείο είναι η
\textit{συνάρτηση}. Δημιουργείται ένα γράφημα δηλαδή για την κάθε συνάρτηση με
ένα σημείο εισόδου (entry point), στην αρχή φυσικά της συνάρτησης και ένα ή
περισσότερα σημεία εξόδου ανάλογα με τις ανάγκες. Για την παραγωγή του κάθε
γραφήματος ο κώδικας χωρίζεται σε κομμάτια (\textit{basic blocks}), στα οποία η
ροή του προγράμματος ξεκινάει μόνο από ένα σημείο στην αρχή και τελειώνει σε ένα
και μοναδικό σημείο στο τέλος. Τα τυχόν παρακλάδια (branches ή forks) του
προγράμματος οργανώνονται βάσει τον blocks αυτών. Αυτό σημαίνει ότι δεν μπορούν
να υπάρξουν branches στη μέση των blocks, οπότε όλες οι δηλώσεις και οι εντολές
(\textit{statements}) θα πρέπει να τρέξουν διαδοχικά. Τα branches όπως είπαμε
βρίσκονται έξω από τα blocks και οδηγούν στα επόμενα σύμφωνα με την ροή του
προγράμματός μας. Από το σημείο του γραφήματος, μόνο το πρώτο statement είναι
"ορατό" και αν η ροή πάει στο block, θα πρέπει αυτό να τρέξει ολόκληρο.

Ένα block μπορεί να ξεκινάει είτε με το entry point ενός branch είτε να είναι το
target ενός branch, και να τελειώνει είτε με μια οδηγία άλματος (jump statement)
είτε με οδηγία συνθήκης (conditional statement· δηλαδή if) είτε τέλος με οδηγία
"επιστροφής" (return statement), η οποία τερματίζει ολόκληρο το graph της
εκάστοτε συνάρτησης.

Οι μέθοδοι βελτιστοποίσης χωρίζονται σε τοπικές (local) και καθολικές (global).
Οι πρώτες δουλεύουν αποκλειστικά αλλάζοντας statements κ.α. μέσα στα blocks και
οι δεύτερες δουλεύουν στις σχέσεις μεταξύ των blocks. Φυσικά πολύ πιο απλές στον
σχεδιασμό και στην υλοποίηση είναι οι πρώτες. Παρακάτω δίνονται κάποια
παραδείγματα. (Πολλές από τις τοπικές που θα συζητήσουμε πρώτα έχουν αντίστοιχες
καθολίκες που βασίζονται στην ίδια αρχή.) Επίσης όπως θα δούμε  υπάρχουν οι
λεγόμενες βελτιστοποιήσεις μηχανής.


\subsection{Τοπικές Μέθοδοι Βελτιστοποίησης}

\begin{itemize} \item Αναδίπλωση Σταθερών

Με τον όρο "Αναδίπλωση Σταθερών" (\textit{Constant folding}) αναφερόμαστε στον
εντοπισμό των τελεστέων κάποιων δηλώσεων/διαδικασιών/οδηγιών που μπορούν να
αποτελέσουν ή ήδη αποτελούν σταθερές. Στην πιο απλή μορφή της θα αντικαταστήσει
αριθμιτικές πράξεις, π.χ.: Ένα statement όπως: $ a = 4 * 2 + 3 $ θα μετατραπεί
σε $ a = 11 $, αποφεύγοντας έτσι τις πράξεις αύτες κατά το runtime. Η απόδειξη
ότι αυτή η αντικατάσταση μπορεί να γίνει διατηρώντας την ορθότητα είναι
προφανής, αφού η πράξη αυτή απλώς πρέπει να εκτελεστεί μια φορά. Άπαξ και την
εκτελέσει ο μεταφραστής, η ορθότητα διατηρείται.

\item Αναδίπλωση Επαναλήψεων

Σε πολλές περιπτώσεις – ειδικά αν ο μεταγλωττιστής αναγνωρίσει ότι πρόκειται για
επανάληψη με συγκεκριμένο σκοπό π.χ. αρχικοποίηση πίνακα – η επανάληψη μπορεί να
εξαλειφθεί. Στην θέση της θα εισαχθεί ίσως κάποιο ειδικό construction του
compiler ή της γλώσσας για αρχικοποίηση σε $O(1)$ (ή έστω κάτι πιο γρήγορο από
το αρχικό).

\item Αναδιάδοση Σταθερών

Σε περίπτωση που ένα statement που έχει μορφή σταθεράς (είτε όπως προηγουμένως 
μια σειρά από πράξεις είτε απλώς ένας αριθμός είτε τέλος μια συμβολοσειρά) 
ανατεθεί σε μια μεταβλητή, τότε ο μεταφραστής μπορεί να την αντικαταστήσει με 
την ίδια την σταθερά. Αυτό μπορεί να συμβεί μόνο στην περίπτωση που ενδιάμεσα 
στις χρήσεις της μεταβλητής δεν υπάρχει άλλη ανάθεση (δηλαδή αλλαγή των 
περιεχομένων της μεταβλητής). Μπορεί αρχικά να φαίνεται ότι η βελτίωση θα είναι 
μικρή αφού σώνουμε έναν μικρό αριθμό προσπελάσεων μνήμης αλλά σε κάποιες 
αρχιτεκτονικές (π.χ. RISC) υπάρχουν τεράστια αποτελέσματα και η μέθοδος αυτή 
είναι εξαιρετικά αποτελεσματική καθώς μειώνεται και ο αριθμός των καταχωρητών (
registers) που χρησιμοποιούνται στην τελική έκδοση του προγράμματος σε κώδικα 
μηχανής. Αυτό συμβαίνει γιατί στην περίπτωση της MISC το σύστημα 
διευθυνσιοδότησης δουλεύει με πρόσθεση ένος register και ενός σταθερού offset.

\item Αναδιάδοση

Ομοίως με παραπάνω μπορεί να γίνει κάτι παρόμοιο στην περίπτωση απλώς
μεταβλητών.

\item Αλγεβρική Απλοποίηση

Ο μεταφραστής μπορεί να χρησιμοποιήσει συγκεκριμένους αλγεβρικούς συνδιασμούς (
τους οποίους γνωρίζει \textit{a-priori}) και ξέρει ότι λειτουργούν και τρέχουν 
πιο γρήγορα από άλλους. Επίσης είναι δυνατόν να χρησιμοποιηθούν αλγεβρικές 
ιδιότητες για να απλοποιηθούν οι παραστάσεις και να χρειάζονται λιγότερες 
πράξεις, λ.χ:
\[
(x+y)^2 = x^2 + 2xy + y^2
\]
Προφανώς το αριστερό μέλος θέλει πολύ λιγότερες πράξεις από το δεξί.
Τέλος πολλές πράξεις μπορούν να αφαιρεθούν αν κριθούν μη-απαραίτητες. Λαμπρό 
παράδειγμα η πρόσθεση με το μηδέν κλπ.

\item Ενίσχυση Δύναμης Τελεστή

Κατά την εφαρμογή της μεθόδου "Ενίσχυσης Δύναμης Τελεστή" ο μεταφραστής
αποπειράται να αντικαταστήσει συγκεκριμένους τελεστές με άλλους λιγότερο
"ακριβούς". Φυσικά αυτό έχει να κάνει με την αρχιτεκτονική. Λ.χ σε κάποια μπορεί
η έκφραση $ x * 2 $ να είναι πιο ακριβή από την $ 2 * x $.

\item Διαγραφή "Νεκρού" Κώδικα

Στην περίπτωση που ο μεταφραστής αντιληφθεί ότι κάποια σημεία του γραφήματος
ροής δεν μπορούν να προσπελαστούν σε καμιά περίπτωση και με καμία είσοδο, τότε
το απροσπέλαστο αυτό block καλείται \textit{νεκρός κώδικας} και μπορεί να
διαγραφεί με ασφάλεια.

\item Εξάλειψη Εκφράσεων Κοινών Αποτελεσμάτων

Όταν ο μεταφραστής εντοπίσει δύο εκφράσεις που παράγουν το ίδιο αποτέλεσμα τότε 
μπορεί με ασφάλεια να αφαιρέσει την μια και να εισάγει ένα reference προς την 
άλλη.

\end{itemize}

\subsection{Καθολικές Μέθοδοι Βελτιστοποίησης}

Μέθοδοι που αλλάζουν statements και συνδέσεις (links) μεταξύ των blocks.

\begin{itemize}

\item Μετακίνηση Κώδικα (Code Motion)

Σε κάποιες περιπτώσεις ο μεταφραστής εντοπίζει κομμάτια κώδικα μέσα σε διάφορα
και/ή ξεχωριστά block, που είτε επαναλαμβάνονται είτε παράγουν το ίδιο
αποτέλεσμα. Τότε αυτά μπορούν να μετακινηθούν σε ένα σημείο και να συμβούν μια
φορά. Σημαντικότερο παράδειγμα, κώδικας μέσα σε loop που απαιτείται να τρέξει
μόνο μια φορά και όχι σε κάθε επανάληψη (iteration). [Λέγεται επίσης και code
hoisting.]

\end{itemize}

\subsection{Μέθοδοι Βελτιστοποίησης Μηχανής}

\begin{itemize}

\item Δέσμευση Καταχωρητών

Ίσως η πιο σημαντική μέθοδος βελτιστοποίησης είναι η σωστή δέσμευση των
καταχωρητών (registers) του επεξεργαστή. Οι καταχωρητές είναι η πιο γρήγορη
μορφή μνήμης αφού βρίσκονται πολύ κοντά στον επεξεργαστή. Για αυτό όμως είναι
και λίγοι και σπανίζουν. Οι πιο αποτελεσματικές μέθοδοι πρέπει να προσδιορίσουν
ποιές μεταβλητές και πότε θα βρίσκονται στους καταχωρητές για να
ελαχιστοποιήσουν τα memory accesses, τα conflicts και τα races. Δηλαδή να
ελαχιστοποιήσουν την κίνηση δεδομένων από και προς τον επεξεργαστή. Ένας πολύ
αποτελεσματικός αλγόριθμος είναι ο λεγόμενος "χρωματισμός" (register  coloring).
Εκτός από τους καταχωρητές ο εκάστοτε αλγόριθμος θα πρέπει να  οργανώσει φυσικά
και όλη την ιεραρχία μνήμης, λαμβάνοντας υπόψιν του και τα  κρυφά επίπεδα μνήμης
της κάθε αρχιτεκτονικής (cache).

\item Χρονολόγηση Εντολών (Instruction Scheduling)

Άλλη μία σημαντική μέθοδος. Ο μεταφραστής καλείται να ανακαλύψει την 
ιδανικότερη σειρά με την οποία θα οργανωθούν οι εντολές στον χρόνο, έχοντας 
υπόψιν του τις ιδιορρυθμίες και τα ειδικά χαρακτηριστικά του κάθε επεξεργαστή 
και αρχιτεκτονικής. Οι λεπτομέρειες περιλαμβάνουν: ικανότητες pipelining, 
πλήθος διαθέσιμων εντολών (RISC/MISC), την χρήση big ή small endian κ.α.

\item Βελτιστοποιήσεις "Κλειδαρότρυπας" (Peephole)

Εδώ περιλαμβάνονται μέθοδοι που σχετίζονται με την εκάστοτε μηχανή. Σε κάθε 
επανάληψη εξετάζονται μερικές από τις επόμενες εντολές (εξού και το όνομα \
textit{κλειδαρότρυπα}) και βελτιώνονται αντίστοιχα. Παράδειγμα: η αποφυγή 
φόρτωσης δεδομένων όταν η προηγούμενη εντολή φορτώνει τα δεδομένα αυτόματα.

\end{itemize}

Στο επόμενο κεφάλαιο αναλύεται αρχικά η διακασία μεταγλώττισης του pypy (για
λόγους κατανόησης), και έπειτα πιο λεπτομερώς η μέθοδος που θα
χρησιμοποιήσουμε στην υλοποίηση του pypy module.

%------------------------------------------------------------------------------
