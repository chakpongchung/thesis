%------------------------------------------------------------------------------

\chapter{Διαδικασία Μεταγλώττισης στο RPython}
\label{chapter3a} 

Το κεφάλαιο αυτό θα αναλύσει ότι χρειάζεται να ξέρει ο αναγνώστης για να
κατανοήσει το κεφάλαιο της υλοποίησης. Θα περιγράψουμε εκτενέστερα την
διαδικασία που ακολουθείται στο σύστημα RPython για την μεταγλώττιση (π.χ. του
PyPy), έτσι ώστε να ξέρει ο αναγνώστης σε ποιο ``χρονικό" σημείο θα λάβει χώρα
το εγχείρημά μας. Στο επόμενο κεφάλαιο θα παραθέσουμε με λεπτομέρεια την
θεωρία της μεθόδου που θα υλοποιήσουμε.

\section{Επισκόπηση}

Ο σκοπός του συστήματος και του \textit{toolchain} του RPython είναι να
μεταφράσει προγράμματα (κυρίως μεταφραστές) γραμμένα σε RPython με
αποτελεσματικότητα ανεξάρτητα με το ποια πλατφόρμα είναι το target του. Το
default target είναι το \textit{C backend} (παραγωγός κώδικα C) και σε αυτό θα
αναφερόμαστε όταν δίνουμε παραδείγματα.

Το σύστημα στην πραγματικότητα δεν βλέπει ποτέ κανονικό κώδικα Python ή
δέντρα, αλλά ξεκινά με \textit{αντικείμενα κώδικα} (code objects) βασισμένα
στις συναρτήσεις που έχουν δοθεί ως είσοδος και τα μετατρέπει με
\textit{abstract interpretation}\cite{CousotCousot77}\cite{debray1995abstract}
σε γραφήματα ροής. Η βασική δηλαδή δομή δεδομένων (unit), πάνω στην οποία
δουλεύει το σύστημα επομένως, είναι τα γραφήματα ροής (σε SSA\cite{ssa} form)
βασισμένα σε function code objects. Ένα γράφημα για κάθε συνάρτηση. Αυτά τα
γραφήματα είναι απλώς ένας ακόμα τρόπος αναπαράστασης του προγράματος, αλλά
πιο κατάλληλος για ``αφαιρετικές" εργασίες μεταγλώττισης και βελτιστοποίσης
(π.χ. εξαγωγή τύπων\footnote{βλ. type inference}).

Η διαδικασία είναι οργανωμένη σε στάδια (βλ. Σχήμα \ref{figure-1}).

\begin{enumerate}

\item \textbf{Import \& Flow Analysis}: Εδώ ο αρχικός κώδικας φορτώνεται στην
μνήμη και υφίσταται τις βασικές διαδικασίες συντακικής ανάλυσης. Μετατρέπεται
αρχικά σε tokens, έπειτα σε μια ενδιάμεση μορφή (Python bytecode) – όπως σε
όλους τους μεταγλωττιστές – και τέλος στα διαγράμματα ροής του PyPy. Από αυτό
το στάδιο και έπειτα φυσικά βρίσκεται μόνο μέσα στην τοπική μνήμη, σε μια 
αρκετά ``στατική" μορφή για τα δεδομένα του RPython.

\item \textbf{Annotator subsystem}: Εδώ ενεργοποιούνται οι περισσότερο
αφαιρετικές μέθοδοι ερμηνείας του κώδικα. Μια καθολική ανάλυση, που θα 
ξεκινήσει από το σημείο εισόδου του κάθε διαγράματος (entry point), θα ``εξάγει"
γενικές πληροφορίες για τον κώδικα και θα συμπεράνει τους τύπους που μπορεί η 
κάθε μεταβλητή να φιλοξενήσει κατά το runtime βάσει φυσικά των συμφραζομένων.
Μετά από αυτό το βήμα, έχουμε annotated flow graphs.

\item \textbf{RTyper}: Αυτό το σύστημα χρησιμοποιεί τους
\textit{υποσημειώμένους} είδικούς προσωρινούς τύπους που έχει προσθέσει ο
annotator για να μετατρέψει τα statements και τις εντολές στα γραφήματα σε
εντολές χαμηλότερου επιπέδου. Είναι ουσιαστικά μια γέφυρα μεταξύ των γραφημάτων
και των παραγωγών κώδικα.

\item \textbf{Optimizations}: Η βελτιστοποίηση στο PyPy γίνεται εδώ. Το project
περιλαμβάνει – και εφαρμόζει –  μια πληθώρα βελτιστοποιήσεων, όπως αυτά που
αναφέραμε στο κεφάλαιο \ref{chapter2}. Επίσης το δικό μας module θα λάβει χώρα
εδώ.

\item \textbf{Προετοιμασία Γραφημάτων}: Εδώ γίνονται οι τελικές ενέργειες πριν
την παραγωγή κώδικα. Τα γραφήματα εδώ λ.χ. υφίσταντο ανάλυση για τον υπολογισμό
ονομάτων μεταβλητών (για λόγους όπως debugging) κ.α. Σημαντικότερες όμως είναι
οι εξής ενέργειες:

\begin{itemize}

\item \textbf{Exception transformer}: Ο ``μετατροπέας εξαιρέσεων" ενεργοποιείται
σε αυτό το σημείο και θα εισάγει τον απαραίτητο κώδικα για τη διαχείριση των
εξαιρέσεων που τυχαίνει να υπάρχουν.

\item \textbf{Garbage Collection Transformer}: Εδώ παίρνει σειρά το ειδικό
εργαλείο διαχείρισης ``σκουπιδιών μνήμης". Αυτό εκτελεί όποιες ενέργειες
χρειάζονται για την σωστή διαχείριση μνήμης. Αφού η Python είναι πλήρως 
δυναμική γλώσσα και δεν απαιτεί από τον προγραμματιστή να διαχειρίζεται την 
μνήμη που χρειάζεται μόνος του, είναι απαραίτητη η ύπαρξη ενός υποσυστήματος
διαχείρισης σκουπιδιών μνήμης.

\end{itemize}

\item \textbf{Code Generation}: Εδώ τα ήδη μαρκαρισμένα, σημειωμένα,
βελτιστοποιημένα γραφήματα θα μετατραπούν σε κώδικα μηχανής. Εδώ υπάρχουν 
πολλοί ``γεννήτορες" κώδικα ανάλογα με τις ανάγκες. Ο βασικότερος και ο πιο 
σημαντικός είναι ο παραγωγός κώδικα C. Αρχικά, τα γραφήματα θα μετατραπούν σε 
άλλα αντίστοιχα, ανάλογα με τον γεννήτορα και έπειτα αυτά θα μετατραπούν σε
κώδικα ανάλογα με την επιλογή (π.χ σε κώδικα C)

\item Τέλος ο κώδικας αυτός θα οδηγηθεί στον μεταφραστή της εκάστοτε επιλογής
(π.χ. \texttt{gcc}) για να παραχθεί το εκτελέσιμο αρχείο.

\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{diagram.png}
\caption{diagram of RPython translation process}
\label{figure-1}
\end{figure}

\section{Γραφήματα Ροής}

\subsection{Τρόπος δημιουργίας}

Ο σκοπός του κατασκευαστή γραφημάτων (υλοποιημένος στο module
\texttt{rpython.flowspace}) είναι να μετατρέψει τα αντικείμενα συναρτήσεων σε
γραφήματα. Κανονικά οι μεταγλωττιστές παίρνουν μια συνάρτηση και την
μετατρέπουν σε ενδιάμεσο bytecode κώδικα σε κάποια εικονική μηχανή (VM) και
έπειτα την τρέχουν. Στο RPython όμως χρησιμοποιείται ένα \textit{abstract
interpretation} το οποίο λειτουργώντας αφαιρετικά μετατρέπει τον ενδιάμεσο
κώδικα στα βασικα \texttt{Block}, τα οποία περιέχουν όλες τις εντολές οι
οποίες επιδρούν πάνω σε αντικείμενα Python. Το αποτέλεσμα της κάθε εντολής
αποθηκεύεται προσωρινά σε μια μεταβλητή η οποία μπορεί να χρησιμοποιηθεί στις
επόμενες. Για ένα παράδειγμα βλ. Σχήμα \ref{figure-2} το οποίο είναι ένα
γράφημα μιας απλής συνάρτησης με ένα if branch. Φαίνεται η γενική εικόνα των
γραφημάτων, το branch καθώς ο τρόπος που επαναχρησιμοποιούνται οι προσωρινές
μεταβλητές αποτελεσμάτων ανάλογα με τις ανάγκες.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{simple-func-bef.png}
\caption{simple function flow diagram}
\label{figure-2}
\end{figure}

Ο κατασκευαστής ``κλείνει" ένα \texttt{Block} και πάει στο επόμενο σε 2 
περιπτώσεις:

\begin{enumerate}

\item Περίπτωση κλήσης \texttt{is\_true()}. Όταν συμβαίνει αυτό, ο \textit{
abstract interpreter} δεν ξέρει φυσικά αν η συνθήκη θα είναι \textit{True} ή
\textit{False} - αφού η γλώσσα μας είναι δυναμική – οπότε θα πρέπει να τις 
ακολουθήσει και τις 2, δημιουργώντας αντίστοιχα άλλες ροές (δηλαδή
\texttt{Blocks}) για την κάθεμια.

\item Περίπτωση εμφάνισης \textit{joinpoint}. Αυτή η περίπτωση λαμβάνει χώρα
όταν η επόμενη εντολή, που πρόκειται να καταγράψουμε στο τρέχον \texttt{Block},
έχει ήδη καταγραφεί ή καταγράφεται τώρα από άλλο \texttt{Block}. Αυτό σημαίνει
ότι ο μεταγλωττιστής έχει κλείσει κάποιον βρόγχο και πρόκειται να μεταγλωττίσει
κώδικα τον οποίο έχει ήδη ``δει". Τότε ο μεταγλωττιστής σταματά, και
δημιουργείται ένα \texttt{Link} απο το τρέχον \texttt{Block} στο προηγούμενο,
έτσι ώστε να κλείσει ο βρόγχος και στο διάγραμμα και να υπάρχει πιστή
αναπαράσταση του κώδικα.

\end{enumerate}

\subsection{Το μοντέλο}

Η βασική συνάρτηση που δημιουργεί τις δομές δεδομένων που απαρτίζουν το μοντέλο
είναι η \texttt{build\_flow()}. Η μονάδα (unit) ροής είναι το αντικείμενο
\texttt{FunctionGraph} το οποίο μαζί με τα υπόλοιπα (που συνήθως περιέχονται σε
αυτό) ορίζονται στο αρχείο \texttt{rpython/flowspace/model.py}. Τα περιγράφουμε
παρακάτω:

\begin{itemize}

\item \texttt{FunctionGraph} Το διάγραμμα ροής μια συνάρτησης. Είναι η βασική
δομή δεδομένων του μεταγλωττιστή. Περιέχει αναφορές και μια λίστα απο
\texttt{Blocks}, τα οποία συνδέονται με \texttt{Links}. Βασικά κομμάτια του
είναι:

\begin{enumerate}
\item \textbf{startblock:} Το πρώτο block του γραφήματος. Είναι το σημείο
εισόδου για την ροή του προγράμματος όταν αυτή φτάσει σε αυτή την συνάρτηση. Οι
παράμετροι εισόδου θα δοθούν σε αυτό το block. Αυτό το block θα δείχνει όπως
και όλα τα άλλα σε επόμενα ανάλογα με την ροή.
\item \textbf{returnblock:} Το μοναδικό block στο κάθε γράφημα που μπορεί να
εκτελέσει μια ``επιστροφή" της συνάρτησης στην ροή του ανώτερου επίπεδου
(function return). Είναι πάντα άδειο και δεν περιέχει ούτε την εντολής
επιστροφής – αυτή υπονοείται. Τα links δείχνουν εδώ όταν και μόνο όταν θέλουν
να τερματίσουν την συνάρτηση. Η μοναδική παράμετρος είναι η τιμή επιστροφής.
\item \textbf{exceptblock:} Αυτό και το παραπάνω είναι τα μόνα blocks που
μπορούν να τερματίσουν την ροή. Είναι το μοναδικό block που μπορεί να
``πυροδοτήσει" μια εξαίρεση. Δέχεται 2 τιμές· η πρώτη είναι η κλάση της εξαίρεσης
και η δεύτερη η τιμής της. Η μόνη περίπτωση να υπάρχει link προς αυτό το block
είναι η ρητή πυροδότηση εξαίρεσης από το πρόγραμμα.
\end{enumerate}

\item \texttt{Block} Το πιο σημαντικό κομμάτι ενός γραφήματος. Ένα γράφημα
ουσιαστικά είναι μια λίστα από blocks. Ένα block περιέχει μια λίστα από
\texttt{SpaceOperation}s, δηλαδή μια λίστα από εντολές. Λεπτομερειακά
αποτελείται από:

\begin{enumerate}
\item \textbf{inputargs:} Είναι μια λίστα με όλες τις μεταβλητές (με καινούργια
ονόματα) που μπορούν να εισέλθουν στο block από οποιοδήποτε προηγούμενο. Η
αντιστοίχηση των παλιών ονομάτων που υπάρχουν στα links με τα καινούργια 
γίνεται ένα προς ένα (π.χ. η πρώτη στα link με την πρώτη στη λίστα).
\item \textbf{operations:} Η λίστα με τις εντολές που θα τρέξουν όταν η ροή
καταλήξει σε αυτό το block. Θα τρέξουν όλες σειριακά χωρίς εξαιρέσεις. Οι
εντολές υποδεικνύονται από \texttt{SpaceOperation}s (βλ. πιο κάτω).
\item \textbf{exits:} Λίστα με πιθανά \textit{άλματα} (jumps). Φυσικά περιέχει
links. Σε ``συνεργασία" με το επόμενο μέλος καθορίζει που θα προχωρήσει η ροή 
του προγράμματος. Φυσικά περιέχει ένα ή περισσότερα links.
\item \textbf{exitswitch:} Τα περιεχόμενα αυτού του μέλους ποικίλλουν:

\begin{enumerate}
\item Δεν υπάρχει \textit{jump} και περιέχει \texttt{None}. Το \textit{exits}
περιέχει ένα link.
\item Άλμα υπό συνθήκη. Σε αυτή την περίπτωση το \textit{exitswitch} είναι μια
από τις μεταβλητές του block. Σε συνεργασία με ένα αντίστοιχο
\textit{exitcase} στα \texttt{Link}s, διευθετεί τις περιπτώσεις των branches.
Η ροή θα ακολουθήσει το \texttt{Link}, του οποίου το \textit{exitcase},
ταιριάζει με το \textit{exitswitch} του \texttt{Block}. Αν δεν υπάρχει 
ταίριασμα τότε έχουμε runtime error.
\item Εξαίρεση. Το \textit{exitswitch} περιέχει
\texttt{Constant(last\_exception)}. Το πρώτο \texttt{Link} του \textit{exits}
περιέχει \texttt{None} στο \textit{exitcase} του για την περίπτωση που δεν
υπάρχει εξαίρεση. Τα υπόλοιπα links δείχνουν στα διάφορα classes των εξαιρέσεων
και ακολουθούνται αντίστοιχα. Φυσικά με αυτόν τον τρόπο ``προστατεύτεται" μόνο η
τελευταία εντολή.
\item Επιστροφή. Περίπτωση \textit{Returnblock}. Το \textit{exitswitch}
και το \textit{operations} είναι άδεια και το \textit{exits} είναι ρυθμισμένο 
σε \texttt{None}.
\end{enumerate}

\end{enumerate}

\item \texttt{Link} Αποτελεί την σύνδεση μεταξύ των Blocks. Περιέχει:

\begin{enumerate}
\item \textbf{prevblock:} Το προηγούμενο \texttt{Block} από το οποίο δείχνει 
αυτό το \texttt{Link}.
\item \textbf{target:} Το \texttt{Block} στο οποίο δείχνει. Μπορεί να είναι 
μόνο ένα. Αν το \texttt{Block} πρέπει να δείξει σε περισσότερα, τότε πρέπει να 
υπάρχουν πολλά \texttt{Link}s.
\item \textbf{args:} Λίστα με \texttt{Variable}s και \texttt{Constant}s. Βλ. 
παραπάνω.
\item \textbf{exitcase:} Βλ. παραπάνω.
\item \textbf{last\_exception:} Εδώ θα τοποθετηθεί (στο runtime) η κλάση 
εξαίρεσης σε τέτοια περίπτωση, αν το \texttt{Link} δείχνει σε \texttt{Block} 
εξαιρέσεων.
\item \textbf{last\_exc\_value:} Ομοίως εδώ θα τοποθετηθεί η τιμή.
\end{enumerate}

\item \texttt{SpaceOperation} Υποδεικνύει μια ``εντολή". Είτε καταγεγραμμένη 
είτε δημιουργημένη από τον ίδιο τον μεταφραστή. Σε αυτό το σημείο οι εντολές 
είναι σχετικά περιορισμένες (λ.χ. δεν μπορούν να πυροδοτήσουν μια εξαίρεση).
Αυτό σημαίνει ότι ο μεταφραστής μπορεί να υποθέσει ότι είναι ασφαλείς και να
εκτελέσει ενεργειες (όπως ανάγνωση μνήμης) που σε άλλες περιπτώσεις θα
απαιτούσαν π.χ. locking. Υπάρχουν 2 πιθανές εξαιρέσεις σε αυτό το σενάριο.

\begin{itemize}
\item η περίπτωση κλήσης άλλης συνάρτησης (βλ. \texttt{simple\_call()})
\item η τελευταία εντολή σε ένα \texttt{Block} χειρισμού εξαιρέσεων μπορεί να
μην είναι ασφαλής.
\end{itemize}

Περιέχει:

\begin{enumerate}

\item \textbf{opname:} Το όνομα της εντολής. Η λίστα με τις εντόλες βρίσκεται 
στο αρχείο \texttt{rpython.flowspace.operation}.
\item \textbf{args:} Τα ορίσματα της εντολής. Μπορεί να είναι \texttt{Constant}
ή \texttt{Variable} αλλά να περιέχεται στο Block.
\item \textbf{result:} καινούργια μεταβλητή στην οποία θα αποθηκευτεί το 
αποτέλεσμα.
\end{enumerate}

\item \texttt{Variable} Αποτελεί ένα placeholder και θα αποκτήσει τιμή κατά το
runtime. Μπορεί προφανώς να είναι όρισμα σε κάποια εντολή. Περιέχονται κάποια 
μέλη με σκοπούς debugging.

\begin{enumerate}
\item \textbf{name:} Εγγυημένα μοναδικό όνομα. Δεν ταιριάζει φυσικά με το 
όνομα που έχει η μεταβλητή στον κώδικα του χρήστη.
\end{enumerate}

\item \texttt{Constant} Αποτελεί την αναπαράσταση μιας σταθεράς. Όπως και 
παραπάνω μπορεί να είναι όρισμα σε κάποια εντολή, ή να βρίσκεται στην λίστα 
κάποιου Link για την αρχικοποίηση των μεταβλητών του επόμενου Block.

\begin{enumerate}
\item \textbf{value:}
\item \textbf{key:} hashed\footnote{βλ. hash function} αντικείμενο που 
αντιπροσωπεύει την τιμή του \textit{value}, για λόγους ασφάλειας κ.α.
\end{enumerate}

\end{itemize}

\section{Πέρασμα Υποσημειώσεων – Annotation Pass}

Αυτό το υποσύστημα ``υποσημειώνει" τα γραφήματα με ειδικές πληροφορίες
(υπογραφές) έτσι ώστε τα επόμενα υποσυστήματα να γνωρίζουν τους εκάστοτε τύπους
των μεταβλητών και των αντικειμένων. Μπορούμε να πούμε ότι είναι ένα είδος
\textit{type inference}. Μία από αυτές τις υπογραφές για τις μεταβλητές, που θα
υποσημειωθούν, θα περιγράφει όλους τις πιθανούς τύπους που θα είναι δυνατόν να
περιέχει η μεταβλητή αυτή κατά την διάρκεια του runtime. Η ανάλυση/πέρασμα
γίνεται ανά συνάρτηση-γράφημα. Το αποτέλεσμα είναι ένα μεγάλο dictionary που
``δείχνει" από μεταβλητές σε τέτοιες υπογραφές.

Η υπογραφή είναι ένα ``στιγμιότυπο" (\textit{instance}) μιας υποκλάσης ενός
\texttt{SomeObject} αντικειμένου. Κάθε υποκλάση αντιπροσωπεύει και μια άλλη
οικογένεια αντικειμένων. Η κλάση βάσης, όπως είπαμε, είναι η
\texttt{SomeObject}, η οποία αντιπροσωπεύει ένα αντικείμενο Python. Υποκλάσεις
της είναι – μεταξύ άλλων – οι: \texttt{SomeInteger()} (με την επιλογή
\texttt{nonneg=True} ανάλογα άν χρειάζονται αρνητικοί αριθμοί),
\texttt{SomeString()}, \texttt{SomeChar()} και \texttt{SomeTuple()}, οι οποίοι
αντιπροσωπεύουν τα προφανή αντικείμενα. Να σημειώσουμε εδώ ότι όλα τα παραπάνω 
αντικείμενα υπογραφών είναι αμετάβλητα, δηλαδή δεν αλλάζουν \textit{in-place}. 
Αυτό σημαίνει ότι εάν ο Annotator αποφασίσει να αλλάξει την υπογραφή, θα 
πρέπει να δημιουργήσει ένα καινούργιο αντικείμενο.

Υπάρχουν αντικείμενα βέβαια τα οποία είναι μεταβλητά, καθώς και αυτά που
αντιπροσωπεύουν χρήζουν προσοχής και ειδικής μεταχείρησης. Σε αυτά, οι 
πληροφορίες μεταβάλλονται καθ όλη την διάρκεια του annotation pass.
Περιλαμβάνουν το \texttt{SomeList()} και το \texttt{SomeDict()}.

Οι πιο εξειδικευμένες περιπτώσεις έχουν να κάνουν με κλάσεις ορισμένες από τον
χρήστη (\textit{user-defined classes}). Το σύστημα τις διαχειρίζεται με το
\texttt{SomeInstance}. Για κάθε τέτοια κλάση διατηρούμε ένα \textit{ClassDef},
που ουσιαστικά περιέχει τα ορίσματα και τα στοιχεία (attibutes) της κλάσης αυτής
σε επίπεδο ορίσματος (class level attibutes) και στιγμιότυπου (instance level
attibutes). Τα τελευταία ``ανακαλύπτονται" προοδευτικά καθώς ο μεταγλωττιστής
προχωρεί κατά μήκος του κώδικα. Για παράδειγμα, το παρακάτω θα μεταβάλει το
\textit{ClassDef} του στιγμιότυπου με το attribute.

\begin{verbatim}
inst.attr = value
\end{verbatim}

Η διαφορές μεταξύ των επιπέδων class και των instance είναι λίγες και λεπτές.
Γενικά τα attibutes των class-level χρησιμοποιούνται ως αρχικοποιητές για τα
αντίστοιχα των instance-level\footnote{Το ίδιο ισχύει και για (μεταβλητές που
περιέχουν) συναρτήσεις.}. Για κάθε attribute σημειώνονται οι θέσεις που
λαμβάνουν χώρα αναγνώσεις και έπειτα, κατά την ανάλυση, αν υπάρχει γενικοποίηση
του attribute για κάποιο λόγο, ο μεταγλωττιστής επιστρέφει σε αυτά τα σημεία και
τα μεταβάλει ανάλογα, κάνοντάς τα \textit{valid} ξανά.

\section{RTyper}

Ο RTyper είναι μια γέφυρα μεταξύ του Annotator και των παραγωγών κώδικα. Είναι
απαραίτητος γιατί ο Annotator υποσημειώνει τον κώδικα με \textit{υπογραφές}
τύπων είτε δημιουργημένους από τον χρήση\footnote{user-defined classes} είτε
πολύ κοντά στο υψηλό επίπεδο της RPython. Οπότε – για να μπορούμε να παράγουμε
κώδικα – απαιτείται η υποσημείωση των γραφημάτων για το επίπεδο της γλώσσας
στόχου, δηλαδή χαμηλού επιπέδου με δείκτες και arrays. Ο RTyper αναλαμβάνει να
αποφανθεί για τον τύπο και να αντικαταστήσει τις εντολές υψηλού επιπέδου με
άλλες αντίστοιχες χαμηλότερου επιπέδου στα γραφήματα. Προφανώς η αντιστοιχία
δεν είναι 1 προς 1, και μερικές φορές απαιτούνται πολύ περισσότερες εντολές στο
χαμηλό επίπεδο για να μιμηθούμε τις αντίστοιχες του υψηλού. Επιπλέον οι
διαθέσιμες εντολές και οι τύποι είναι σαφώς περιορισμένοι. Τελος, πρέπει να
σημειωθεί ότι αυτό το βήμα θα μπορούσε να μην γίνει, αλλά οι σχεδιαστές έχουν
επιλέξει να είναι ένα αυτόνομο module του συστήματος έτσι ώστε να κάνει την
δουλεία του παραγωγού κώδικα πιο εύκολη και πιο αποδοτική. Μετά το πέρασμα του
RTyper η παραγωγή κώδικα είναι σχετικά τετριμμένη.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Προετοιμασία}

\subsection{Διαχείριση Μνήμης}

Αφού η Python είναι δυναμική ενώ οι περισσότερες από τις γλώσσες παραγωγών
(compiled target languages) δεν είναι· θα πρέπει το σύστημα να κάνει κάποιες
επιλογές για την διαχείριση της μνήμης. Αυτές οι επιλογές είναι εξαιρετικά
σημαντικές για την τελική ταχύτητα των προγραμμάτων καθώς γενικά ο κώδικας
Python τείνει να δεσμεύει μνήμη με πολύ γρήγορους ρυθμούς. Το σύστημα είναι
ευέλικτο και υπάρχουν πολλές επιλογές. Δεν θα μπούμε σε επιπλέον πληροφορίες
γιατί είναι έξω από τα όρια σκοπού της εργασίας αυτής, αλλά πληροφοριακά
υπάρχουν:

\begin{itemize}
\item reference counting (απαρχαιωμένο – δεν χρησιμοποιείται πλέον στο σύστημα)
\item ένας συντηρητικός BDW (B\``ohm-Demers-Weiser) συλλέκτης\cite{bdw}
\item πλέον χρησιμοποιούνται άλλοι custom συλλέκτες (βλ. \cite{gc}).
\end{itemize}

\subsection{Διαχείριση Εξαιρέσεων}

Ο κώδικας RPython υποστηρίζει πλήρως συντακτικό εξαιρέσεων ακριβώς όπως και η
κανονική Python. Όπως και πριν βέβαια οι γλώσσες παραγωγών δεν "γνωρίζουν`` την
έννοια των εξαιρέσεων οπότε ο απαραίτητος κώδικας διαχείρισης θα πρέπει να
προστεθεί. Το σύστημα δουλεύει όπως το κανονικό σύστημα της Python στον
μεταγλωττιστή CPython: οι εξαιρέσεις υποδεικνύονται με ειδικές τιμές επιστροφής
(return values) και η τρέχουσα εξαίρεση αποθηκεύεται σε μια καθολική (global)
δομή δεδομένων, ορατή από όλα τα πεδία δράσης (scope) του προγράμματος.

